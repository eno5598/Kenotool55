<!doctype html>
<!--
  KENO High‚ÄëEnd Analyse‚ÄëTool (Version 3, Dezember¬†2025)

  Dieses Tool analysiert dein geladenes KENO‚ÄëArchiv umfassend und berechnet
  mehrere Strategien, die auf verschiedenen Heuristiken basieren. Alle
  Strategien sind rein statistische Ann√§herungen ohne Gewinngarantie ‚Äì
  KENO‚ÄëZiehungen sind zufallsbasiert und werden durch RNG oder physische
  Mischverfahren bestimmt„Äê820644395070059‚Ä†L224-L242„Äë. Jede Zahl hat die
  gleiche Wahrscheinlichkeit zu erscheinen„Äê820644395070059‚Ä†L224-L243„Äë, auch wenn
  bestimmte Muster im Archiv erkennbar sind. Die hier angebotenen Systeme
  dienen lediglich zur Analyse und Inspiration, nicht als sichere
  Vorhersage.

  Strategien:
    * System¬†A ‚Äì Hot/Deviation: h√§ufige und positiv abweichende Zahlen.
    * System¬†B ‚Äì Cold/Rebound: unterrepr√§sentierte Zahlen mit Rebound‚ÄëIdee.
    * System¬†C ‚Äì Pattern/Next‚ÄëDraw: Folge‚ÄëMuster basierend auf √§hnlichen
      Situationen zur letzten Ziehung.
    * System¬†D ‚Äì Gap‚ÄëR√ºckkehr: Zahlen mit langen Pausen & typischem
      Abstands‚ÄëMuster (√ºberf√§llig).
    * System¬†E ‚Äì Odd/Even Balance: ausgewogene Kombination aus geraden
      und ungeraden Zahlen„Äê820644395070059‚Ä†L143-L149„Äë.
    * System¬†F ‚Äì High/Low Balance: ausgewogene Kombination aus niedrigen
      und hohen Zahlen„Äê820644395070059‚Ä†L150-L153„Äë.
    * System¬†G ‚Äì Quadrant‚ÄëCluster: Konzentration auf das aktivste Viertel
      des Zahlenbereichs (Cluster‚ÄëStrategie).

  Hinweise:
    ‚Ä¢ Jede Strategie erstellt einen Kandidatensatz aus 20 Zahlen. Aus
      diesen S√§tzen k√∂nnen Varianten erzeugt werden (Keno‚ÄëTyp w√§hlbar).
    ‚Ä¢ Variantenvorschl√§ge ber√ºcksichtigen √úberschneidungslimits und
      vermeiden vier oder mehr aufeinanderfolgende Zahlen.
    ‚Ä¢ Nach der Generierung kann jede Variante mit dem gesamten Archiv
      verglichen werden, um die historischen Trefferverteilungen zu sehen.
    ‚Ä¢ Geladene Archive werden automatisch im LocalStorage gespeichert und
      beim erneuten √ñffnen der Seite wiederhergestellt. Ein ‚ÄûArchiv
      l√∂schen‚Äú‚ÄëButton entfernt den Cache.

  Copyright¬†¬©¬†2025. Keine kommerzielle Nutzung ohne Genehmigung.
-->
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>KENO High‚ÄëEnd Analyse‚ÄëTool</title>
  <!-- JSZip zum Entpacken von ZIP‚ÄëArchiven im Browser -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    :root {
      --bg: #050816;
      --panel: #111827;
      --border: #1f2937;
      --text: #e5e7eb;
      --accent: #22c55e;
      --accent2: #0ea5e9;
      --danger: #f87171;
      --muted: #9ca3af;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000 100%);
      color: var(--text);
    }
    h1, h2, h3 {
      margin-top: 0;
      color: var(--accent);
      text-shadow: 0 0 6px rgba(34,197,94,0.4);
    }
    .container { max-width: 1200px; margin: 0 auto; }
    .grid {
      display: grid;
      grid-template-columns: minmax(0,1.25fr) minmax(0,1fr);
      gap: 16px;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: minmax(0,1fr); }
    }
    .panel {
      background: linear-gradient(145deg, rgba(15,23,42,0.95), rgba(17,24,39,0.98));
      border-radius: 12px;
      padding: 14px 16px 16px;
      border: 1px solid rgba(148,163,184,0.35);
      box-shadow: 0 18px 40px rgba(15,23,42,0.85);
      position: relative;
      overflow: hidden;
    }
    .panel::before {
      content: "";
      position: absolute;
      inset: -60%;
      background:
        radial-gradient(circle at 10% 0, rgba(56,189,248,0.12), transparent 60%),
        radial-gradient(circle at 90% 100%, rgba(74,222,128,0.12), transparent 55%);
      mix-blend-mode: screen;
      opacity: 0.6;
      pointer-events: none;
    }
    .panel > * { position: relative; }
    label { display: block; margin: 6px 0 4px; font-size: 0.9rem; }
    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 7px 9px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--text);
      font-size: 0.9rem;
    }
    input[type="checkbox"] { margin-right: 4px; }
    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.85);
      color: var(--text);
      cursor: pointer;
      font-size: 0.88rem;
      font-weight: 500;
      transition: background 0.2s, transform 0.15s, box-shadow 0.15s;
    }
    button.primary {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border: none;
      color: #02120a;
      box-shadow: 0 8px 22px rgba(45,212,191,0.4);
    }
    button.primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(45,212,191,0.55);
    }
    button.secondary:hover {
      background: rgba(30,64,175,0.55);
      transform: translateY(-1px);
    }
    button.danger {
      background: rgba(127,29,29,0.95);
      border-color: rgba(248,113,113,0.7);
      color: #fee2e2;
    }
    button.danger:hover {
      background: rgba(185,28,28,1);
      transform: translateY(-1px);
    }
    button:disabled {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    progress {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.9);
      overflow: hidden;
    }
    progress::-webkit-progress-bar { background: transparent; }
    progress::-webkit-progress-value {
      background: linear-gradient(90deg, var(--accent), var(--accent2));
    }
    progress::-moz-progress-bar {
      background: linear-gradient(90deg, var(--accent), var(--accent2));
    }
    .hint {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 3px;
    }
    .status {
      font-size: 0.8rem;
      margin-top: 6px;
    }
    .status.error { color: var(--danger); }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      font-size: 0.75rem;
      color: var(--muted);
    }
    .top-group {
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 8px 10px;
      margin-top: 10px;
      background: radial-gradient(circle at top left, rgba(56,189,248,0.1), transparent 60%);
    }
    .top-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }
    .top-list {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
    }
    .top-number {
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.8);
    }
    .variants-block {
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 8px 10px;
      margin-top: 10px;
      background: radial-gradient(circle at top right, rgba(34,197,94,0.12), transparent 60%);
    }
    .variant-item {
      font-family: ui-monospace, Consolas, Menlo, monospace;
      font-size: 0.82rem;
      border-bottom: 1px dashed rgba(75,85,99,0.6);
      padding: 2px 0;
    }
    .variant-item:last-child { border-bottom: none; }
    .compare-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
      margin-top: 6px;
    }
    .compare-table th,
    .compare-table td {
      border: 1px solid rgba(55,65,81,0.9);
      padding: 2px 4px;
      text-align: center;
    }
    .compare-table th {
      background: rgba(17,24,39,0.9);
      font-weight: 500;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>KENO High‚ÄëEnd Analyse‚ÄëTool</h1>
    <div class="hint">
      Dieses Tool analysiert dein KENO‚ÄëArchiv (Hot/Cold, Deviation, Muster,
      ‚ÄûNext‚ÄëDraw‚Äú, Gap‚ÄëR√ºckkehr, Odd/Even‚ÄëBalance, High/Low‚ÄëBalance,
      Quadrant‚ÄëCluster) und erstellt f√ºr jede Strategie einen Kandidatensatz aus
      20 Zahlen. Aus diesen S√§tzen kannst du Varianten erstellen und mit dem
      gesamten Archiv vergleichen. <strong>Hinweis:</strong> KENO bleibt ein
      Zufallsspiel„Äê820644395070059‚Ä†L224-L243„Äë ‚Äì keine Gewinngarantie.
    </div>
    <div class="grid mt-3">
      <!-- Linke Seite: Archiv & Einstellungen & Analyse -->
      <div class="col-left">
        <!-- Archiv laden -->
        <div class="panel">
          <div class="section-title">Archiv</div>
          <h2>Archiv laden</h2>
          <label for="file">CSV/TXT/ZIP ausw√§hlen</label>
          <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
          <div id="fileStatus" class="hint mt-1">Kein Archiv geladen.</div>
          <div class="mt-2 flex gap-2 flex-wrap">
            <button id="autoLoad" class="secondary">‚¨áÔ∏è Offizielles Archiv automatisch laden</button>
            <label class="hint" style="display:inline-flex; align-items:center; gap:4px;">
              <input type="checkbox" id="autoloadOnStart"> beim Start laden
            </label>
          </div>
          <div class="mt-2 flex gap-2 flex-wrap">
            <div style="flex:1 1 160px; min-width:0;">
              <label for="customUrl">Alternative URL (optional)</label>
              <input type="text" id="customUrl" placeholder="https://example.com/archiv_keno.zip">
            </div>
            <div style="flex:1 1 160px; min-width:0;">
              <label for="customProxy">Proxy (optional)</label>
              <input type="text" id="customProxy" placeholder="https://corsproxy.io/?">
            </div>
          </div>
          <div class="mt-2">
            <progress id="dlProg" value="0" max="1" style="display:none"></progress>
            <div id="loadStatus" class="hint"></div>
          </div>
          <div class="mt-2 flex gap-2 flex-wrap">
            <button id="clearCache" class="danger">üóëÔ∏è Archiv l√∂schen</button>
          </div>
        </div>
        <!-- Einstellungen / Grund-Setup -->
        <div class="panel mt-3">
          <div class="section-title">Grund‚ÄëSetup</div>
          <h2>Grund‚ÄëSetup</h2>
          <!-- Allgemeine Einstellungen -->
          <h3 class="mt-1">Allgemein</h3>
          <div class="flex gap-3 mt-1 flex-wrap">
            <div style="flex:1 1 150px; min-width:0;">
              <label for="kenoType">Keno‚ÄëTyp (Anzahl Zahlen pro Tipp)</label>
              <select id="kenoType">
                <option value="2">Typ¬†2</option>
                <option value="3">Typ¬†3</option>
                <option value="4">Typ¬†4</option>
                <option value="5">Typ¬†5</option>
                <option value="6" selected>Typ¬†6</option>
                <option value="7">Typ¬†7</option>
                <option value="8">Typ¬†8</option>
                <option value="9">Typ¬†9</option>
                <option value="10">Typ¬†10</option>
              </select>
            </div>
            <div style="flex:1 1 150px; min-width:0;">
              <label for="numVariants">Varianten pro Satz</label>
              <input type="number" id="numVariants" value="10" min="1" max="200">
            </div>
            <div style="flex:1 1 150px; min-width:0;">
              <label for="overlapLimit">Max. Overlap (zwischen Varianten)</label>
              <input type="number" id="overlapLimit" value="0" min="0" max="20">
              <div class="hint">0¬†= keine Begrenzung</div>
            </div>
          </div>
          <div class="flex gap-3 mt-1 flex-wrap">
            <div style="flex:1 1 150px; min-width:0;">
              <label for="rangeFrom">Zahlenbereich von</label>
              <input type="number" id="rangeFrom" value="1" min="1" max="200">
            </div>
            <div style="flex:1 1 150px; min-width:0;">
              <label for="rangeTo">Zahlenbereich bis</label>
              <input type="number" id="rangeTo" value="70" min="1" max="200">
            </div>
          </div>
          <!-- Scan-Parameter -->
          <h3 class="mt-3">Scan‚ÄëParameter</h3>
          <div class="flex gap-3 mt-1 flex-wrap">
            <div style="flex:1 1 150px; min-width:0;">
              <label for="scanRounds">Scan‚ÄëIntensit√§t (Runden)</label>
              <input type="number" id="scanRounds" value="3" min="1" max="100">
              <div class="hint">Mehr Runden¬†= l√§ngerer &amp; tiefer Analyse‚ÄëScan.</div>
            </div>
            <div style="flex:1 1 150px; min-width:0;">
              <label for="recentWindow">Fenster ‚Äûletzte Ziehungen‚Äú</label>
              <input type="number" id="recentWindow" value="100" min="10" max="1000">
              <div class="hint">F√ºr Hot/Cold‚ÄëAuswertung.</div>
            </div>
            <div style="flex:1 1 150px; min-width:0;">
              <label for="similarityOverlap">√Ñhnlichkeits‚ÄëSchwelle (Overlap)</label>
              <input type="number" id="similarityOverlap" value="8" min="1" max="20">
              <div class="hint">F√ºr ‚ÄûNext‚ÄëDraw‚Äú: Ziehungen mit √§hnlichem Overlap zur letzten werden st√§rker gewichtet.</div>
            </div>
          </div>
        </div>
        <!-- Analyse -->
        <div class="panel mt-3">
          <div class="section-title">Analyse</div>
          <h2>Scan &amp; Kandidaten</h2>
          <div class="flex gap-2 flex-wrap">
            <button id="scanBtn" class="primary">üß† Archiv scannen</button>
            <span class="pill">Modi: Hot/Cold ¬∑ Pattern ¬∑ Gap‚ÄëR√ºckkehr ¬∑ Odd/Even ¬∑ High/Low ¬∑ Quadrant</span>
          </div>
          <progress id="scanProg" value="0" max="1" style="display:none; margin-top:10px;"></progress>
          <div id="scanStatus" class="status"></div>
          <div class="hint mt-2">
            Der Scan l√§uft in Batches (asynchron), damit der Browser nicht einfriert. Je nach Archivgr√∂√üe und Intensit√§t kann der Scan einige Zeit dauern.
          </div>
          <div id="candidatesSection" style="display:none;" class="mt-3">
            <h3>Kandidatens√§tze</h3>
            <div class="hint">
              Jeder Satz basiert auf einer anderen Strategie. Du kannst einen oder mehrere S√§tze f√ºr die Variantenerzeugung ausw√§hlen.
            </div>
            <div id="candGroups"></div>
          </div>
          <div id="summarySection" style="display:none;" class="mt-3">
            <h3>Analyse‚Äë√úbersicht</h3>
            <div class="hint">
              Kurze Zusammenfassung der wichtigsten Kennzahlen aus dem Archiv. Diese Statistiken dienen als Orientierungshilfe und ersetzen nicht die Heuristiken.
            </div>
            <div id="summaryContent" class="mt-2"></div>
          </div>
        </div>
      </div>
      <!-- Rechte Seite: Varianten & Vergleich -->
      <div class="col-right">
        <!-- Varianten -->
        <div class="panel">
          <div class="section-title">Varianten</div>
          <h2>Varianten aus Kandidaten</h2>
          <div class="flex gap-2 flex-wrap">
            <button id="genBtn" class="primary">üé≤ Varianten erzeugen</button>
            <button id="clearVarBtn" class="secondary">üßπ Varianten leeren</button>
          </div>
          <div id="varStatus" class="status"></div>
          <div id="varBlocks" class="mt-3"></div>
        </div>
        <!-- Vergleich -->
        <div class="panel mt-3">
          <div class="section-title">Historischer Vergleich</div>
          <h2>Varianten vs. Archiv</h2>
          <div class="flex gap-2 flex-wrap">
            <button id="compareBtn" class="primary">üìä Treffer‚ÄëVerteilung berechnen</button>
          </div>
          <progress id="compareProg" value="0" max="1" style="display:none; margin-top:10px;"></progress>
          <div id="compareStatus" class="status"></div>
          <div id="compareResults" class="mt-2"></div>
          <div class="hint mt-2">
            Hier siehst du, wie sich jede Variante historisch verhalten h√§tte ‚Äì wie oft 0‚Ä¶S Treffer im Archiv erzielt wurden. Das dient nur der R√ºckschau und ist keine Garantie f√ºr die Zukunft.
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
  (function(){
    'use strict';
    // Helper Kurzformen
    const $ = s => document.querySelector(s);
    const el = (tag, cls) => { const x = document.createElement(tag); if(cls) x.className = cls; return x; };
    const txt = (node, s) => { if(node) node.textContent = s; };

    const OFFICIAL_ZIP_URL = 'https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip';

    // Globale Daten
    let g_draws = [];       // Liste der Ziehungen (Array von Arrays)
    let g_drawSize = 0;     // typischerweise 20 (wird dynamisch erkannt)
    let g_candidateSets = [];// Liste der Strategien mit Zahlen
    let g_scanSummary = null; // Zusammenfassung (Top‚ÄëZahlen, Paare, Overlaps)
    let g_variantsBySet = {}; // set.id -> Array von Varianten {numbers:[], hist:null}

    // Laden aus LocalStorage bei Start
    const stored = localStorage.getItem('keno_draws');
    if(stored){
      try{
        const parsed = JSON.parse(stored);
        if(parsed.draws && Array.isArray(parsed.draws) && parsed.draws.length){
          g_draws = parsed.draws;
          g_drawSize = g_draws[0].length;
          txt($('#fileStatus'), `${g_draws.length} Ziehungen geladen (je ${g_drawSize} Zahlen) ‚Äì aus Cache`);
        }
      }catch(e){
        console.warn('Cache konnte nicht geladen werden', e);
      }
    }

    // ARCHIV: Datei ausw√§hlen
    $('#file').addEventListener('change', async ev => {
      const file = ev.target.files[0];
      if(!file){ txt($('#fileStatus'),'Keine Datei ausgew√§hlt.'); return; }
      try{
        if(/\.zip$/i.test(file.name)){
          await loadZipFile(file);
        }else{
          const raw = await file.text();
          parseArchive(raw, file.name);
        }
      }catch(e){
        console.error(e);
        txt($('#fileStatus'), 'Fehler beim Laden: ' + e.message);
      }
    });

    // ARCHIV: ZIP-Datei entpacken
    async function loadZipFile(file){
      txt($('#fileStatus'), 'ZIP wird entpackt ‚Ä¶');
      const data = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(data);
      let best = null;
      zip.forEach((path, entry) => {
        const p = path.toLowerCase();
        if(entry.dir) return;
        if(p.endsWith('.csv') || p.endsWith('.txt')){
          const score = (p.includes('keno') ? 3 : 0) + (p.includes('archiv') ? 2 : 0) + (p.endsWith('.csv') ? 1 : 0);
          if(!best || score > best.score) best = {entry, score};
        }
      });
      if(!best){ txt($('#fileStatus'), 'Keine CSV/TXT im ZIP gefunden.'); return; }
      const raw = await best.entry.async('string');
      parseArchive(raw, file.name);
    }

    // ARCHIV: Auto‚ÄëDownload
    $('#autoLoad').addEventListener('click', () => {
      autoLoadOfficialArchive().catch(err => console.error(err));
    });
    window.addEventListener('load', () => {
      if($('#autoloadOnStart').checked){ autoLoadOfficialArchive().catch(err => console.error(err)); }
    });
    async function fetchWithProgress(url, onProgress){
      const res = await fetch(url);
      if(!res.ok) throw new Error('HTTP ' + res.status + ' bei ' + url);
      const total = parseInt(res.headers.get('Content-Length')) || 0;
      const reader = res.body.getReader();
      const chunks = [];
      let received = 0;
      while(true){
        const {done, value} = await reader.read();
        if(done) break;
        chunks.push(value);
        received += value.length;
        if(onProgress) onProgress({received, total});
      }
      const blob = new Blob(chunks);
      return { arrayBuffer: await blob.arrayBuffer(), total: total || received };
    }
    async function attemptDownload(urls, onProgress){
      let lastError = null;
      for(const url of urls){
        try{
          const result = await fetchWithProgress(url, onProgress);
          result.usedUrl = url;
          return result;
        }catch(e){ lastError = e; }
      }
      throw lastError || new Error('Download fehlgeschlagen');
    }
    async function autoLoadOfficialArchive(){
      const prog = $('#dlProg');
      const st   = $('#loadStatus');
      prog.style.display = '';
      prog.value = 0; prog.max = 1;
      txt(st, 'Verbinde zur Quelle ‚Ä¶');
      try{
        const custom = $('#customUrl').value.trim();
        const base = custom || OFFICIAL_ZIP_URL;
        const proxy = $('#customProxy').value.trim();
        const urls = [];
        if(proxy) urls.push(proxy + base);
        urls.push(base);
        urls.push('https://corsproxy.io/?' + encodeURIComponent(base));
        urls.push('https://api.allorigins.win/raw?url=' + encodeURIComponent(base));
        urls.push('https://thingproxy.freeboard.io/fetch/' + base);
        const {arrayBuffer} = await attemptDownload(urls, ({received,total}) => {
          if(total > 0){ prog.value = received/total; txt(st, `Lade Archiv ‚Ä¶ ${(100*received/total).toFixed(0)}%`); }
          else { prog.value = Math.min(1, prog.value + 0.02); txt(st, `Lade Archiv ‚Ä¶ ${received.toLocaleString()}¬†Bytes`); }
        });
        txt(st, 'Entpacke ZIP ‚Ä¶');
        const zip = await JSZip.loadAsync(arrayBuffer);
        const cand = [];
        zip.forEach((path,entry) => {
          const p = path.toLowerCase();
          if(entry.dir) return;
          if(p.endsWith('.csv') || p.endsWith('.txt')){
            const score = (p.includes('keno')?3:0) + (p.includes('archiv')?2:0) + (p.endsWith('.csv')?1:0);
            cand.push({path,entry,score,size: entry._dataUncompressedSize||0});
          }
        });
        if(!cand.length) throw new Error('Keine CSV/TXT im ZIP gefunden.');
        cand.sort((a,b)=> b.score - a.score || b.size - a.size);
        const best = cand[0];
        const raw  = await best.entry.async('string');
        parseArchive(raw, 'auto');
        txt(st, 'Archiv geladen.');
      }catch(err){
        console.error(err);
        txt(st,'Fehler beim Download: ' + err.message);
      }finally{
        prog.style.display = 'none';
      }
    }

    // ARCHIV: Parser
    function parseArchive(raw, sourceName){
      // Split lines, trim, ignore empty
      const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      if(!lines.length){ txt($('#fileStatus'),'Leere Datei.'); return; }
      const candidateRows = [];
      const lengthCount = {};
      for(const ln of lines){
        // skip header lines containing 'zahl' or similar
        if(/zahl\s*1/i.test(ln) || /zahl1/i.test(ln)) continue;
        const nums = ln.match(/\d+/g);
        if(!nums) continue;
        lengthCount[nums.length] = (lengthCount[nums.length]||0) + 1;
        candidateRows.push(nums);
      }
      // Determine the most common length (‚â•10) and default to 20 if available.
      let typicalLength = 0;
      let maxCount = 0;
      for(const lenStr in lengthCount){
        const len = parseInt(lenStr,10);
        const cnt = lengthCount[lenStr];
        if(cnt > maxCount && len >= 10){
          maxCount = cnt;
          typicalLength = len;
        }
      }
      // Many KENO‚ÄëArchive enthalten zus√§tzliche Spalten (z.B. Ziehungsnummer, Gewinnklasse).
      // In solchen F√§llen interessieren uns nur die ersten 20 Zahlen ‚Äì die eigentlichen gezogenen Nummern.
      // Wenn mindestens 20 Zahlen pro Zeile vorhanden sind, wird 20 als ‚Äûtypische‚Äú L√§nge verwendet.
      // Wenn Zeilen mit 20 Zahlen vorhanden sind, oder die ermittelte typische L√§nge >¬†20,
      // beschr√§nken wir die Ziehungsgr√∂√üe auf 20 (Keno zieht immer 20 Zahlen).
      if(lengthCount[20]){
        typicalLength = 20;
      } else if(typicalLength > 20){
        typicalLength = 20;
      }
      if(!typicalLength){
        txt($('#fileStatus'), 'Konnte typische Ziehungsgr√∂√üe nicht bestimmen.');
        return;
      }
      // Build draws: nimm die ersten typicalLength Zahlen der Zeile, auch wenn die Zeile l√§nger ist
      const draws = [];
      for(const arr of candidateRows){
        if(arr.length >= typicalLength){
          const row = arr.slice(0, typicalLength).map(x => parseInt(x,10));
          draws.push(row);
        }
      }
      if(!draws.length){
        txt($('#fileStatus'),'Keine g√ºltigen Ziehungen gefunden.');
        return;
      }
      g_draws = draws;
      g_drawSize = typicalLength;
      // Meldung stets mit der tats√§chlich √ºbernommenen Zahlengr√∂√üe (typicalLength)
      txt($('#fileStatus'), `${draws.length}¬†Ziehungen geladen (je ${typicalLength}¬†Zahlen).`);
      // Persistiere in LocalStorage
      try{
        localStorage.setItem('keno_draws', JSON.stringify({draws}));
      }catch(e){ console.warn('Could not save to LocalStorage', e); }
      // Analyse‚ÄëState zur√ºcksetzen
      resetAnalysisState();
    }

    // Clear stored archive
    $('#clearCache').addEventListener('click', () => {
      localStorage.removeItem('keno_draws');
      g_draws = [];
      g_drawSize = 0;
      g_candidateSets = [];
      g_variantsBySet = {};
      txt($('#fileStatus'),'Cache gel√∂scht.');
      txt($('#scanStatus'),'');
      $('#scanStatus').classList.remove('error');
      $('#candidatesSection').style.display = 'none';
      $('#candGroups').innerHTML = '';
      $('#varBlocks').innerHTML = '';
      $('#varStatus').textContent = '';
      $('#compareResults').innerHTML = '';
      $('#compareStatus').textContent = '';
    });

    // Reset state when new archive loaded
    function resetAnalysisState(){
      g_candidateSets = [];
      g_variantsBySet = {};
    g_scanSummary = null;
      $('#scanStatus').textContent = '';
      $('#scanStatus').classList.remove('error');
      $('#candidatesSection').style.display = 'none';
      $('#candGroups').innerHTML = '';
      $('#varBlocks').innerHTML = '';
      $('#varStatus').textContent = '';
      $('#compareResults').innerHTML = '';
      $('#compareStatus').textContent = '';
  $('#summarySection').style.display = 'none';
  $('#summaryContent').innerHTML = '';
    $('#summarySection').style.display = 'none';
    $('#summaryContent').innerHTML = '';
    }

    // SCAN button
    $('#scanBtn').addEventListener('click', () => {
      scanArchive().catch(err => console.error(err));
    });

    // Analyse & Mustererkennung
    async function scanArchive(){
      if(!g_draws || !g_draws.length){ txt($('#scanStatus'),'Bitte zuerst ein Archiv laden.'); $('#scanStatus').classList.add('error'); return; }
      const A = parseInt($('#rangeFrom').value,10);
      const B = parseInt($('#rangeTo').value,10);
      if(!Number.isInteger(A) || !Number.isInteger(B) || A >= B){ txt($('#scanStatus'),'Ung√ºltiger Zahlenbereich.'); $('#scanStatus').classList.add('error'); return; }
      const scanRounds   = Math.max(1, parseInt($('#scanRounds').value,10) || 1);
      const recentWindow = Math.max(10, parseInt($('#recentWindow').value,10) || 100);
      const similarityOv = Math.max(1, parseInt($('#similarityOverlap').value,10) || 8);
      $('#scanStatus').classList.remove('error');
      txt($('#scanStatus'), 'Initialisiere Scan ‚Ä¶');
      $('#scanProg').style.display = '';
      $('#scanProg').value = 0;
      const totalDraws = g_draws.length;
      // Initialisieren der Statistiken
      const statsNumber = {};
      for(let z=A; z<=B; z++){
        statsNumber[z] = {
          freq: 0,
          gaps: [],
          streaks: [],
          currentStreak: 0,
          lastSeen: -1,
          pairScore: 0,
          followFreq: 0,
          dev: 0,
          gapScore: 0
        };
      }
      const pairCounts = new Map();
      const lastIdx = totalDraws - 1;
      const lastDrawSortedFull = g_draws[lastIdx].slice().sort((a,b)=>a-b);
      let prevSorted = null;
      const chunkSize = 200;
      // Basisscan
      for(let start=0; start<totalDraws; start += chunkSize){
        const end = Math.min(totalDraws, start + chunkSize);
        for(let i=start; i<end; i++){
          const draw = g_draws[i];
          // gefiltert & sortiert im Bereich [A,B]
          const sorted = draw.filter(v => v>=A && v<=B).sort((a,b)=>a-b);
          // Frequenzen, Streaks, Gaps
          for(const v of sorted){
            const st = statsNumber[v];
            st.freq++;
            if(st.lastSeen === i-1) st.currentStreak++; else { if(st.currentStreak>0) st.streaks.push(st.currentStreak); st.currentStreak = 1; }
            if(st.lastSeen >= 0) st.gaps.push(i - st.lastSeen);
            st.lastSeen = i;
          }
          // Paare (vereinfachte Paargewichtung)
          const n = sorted.length;
          for(let a=0; a<n; a++){
            const vA = sorted[a];
            for(let b=a+1; b<n; b++){
              const vB = sorted[b];
              const key = vA + '-' + vB;
              pairCounts.set(key, (pairCounts.get(key) || 0) + 1);
              statsNumber[vA].pairScore++;
              statsNumber[vB].pairScore++;
            }
          }
          prevSorted = sorted;
        }
        $('#scanProg').value = end / totalDraws;
        txt($('#scanStatus'), `Basisscan ‚Ä¶ ${Math.floor(100*end/totalDraws)}%`);
        await new Promise(r=>setTimeout(r,0));
      }
      // Streaks abschlie√üen
      for(let z=A; z<=B; z++){
        const st = statsNumber[z];
        if(st.currentStreak>0) st.streaks.push(st.currentStreak);
      }
      // Hot/Cold: letzte N Ziehungen
      const freqRecent = {};
      for(let z=A; z<=B; z++) freqRecent[z] = 0;
      const startRecent = Math.max(0, totalDraws - recentWindow);
      for(let i=startRecent; i<totalDraws; i++){
        for(const v of g_draws[i]){
          if(v>=A && v<=B) freqRecent[v]++;
        }
      }
      // Erwartete Frequenz basierend auf realer DrawSize in Bereich
      // Wir berechnen: erwartete Treffer pro Zahl = (totalDraws * avgZahlenImBereich pro Ziehung) / poolSize
      let totalNumbersInRange = 0;
      for(const draw of g_draws){
        for(const v of draw) if(v>=A && v<=B) totalNumbersInRange++; }
      const avgInRange = totalNumbersInRange / totalDraws;
      const poolSize = (B - A + 1);
      const expectedFreq = (totalDraws * avgInRange) / poolSize;
      for(let z=A; z<=B; z++){
        statsNumber[z].dev = statsNumber[z].freq - expectedFreq;
      }
      // Next‚ÄëDraw‚ÄëPattern (Follow): √§hnliche Overlaps zur letzten Ziehung
      const lastSet = new Set(lastDrawSortedFull.filter(v => v>=A && v<=B));
      const followFreq = {};
      for(let z=A; z<=B; z++) followFreq[z] = 0;
      for(let i=0; i<lastIdx; i++){
        const cur = g_draws[i].filter(v => v>=A && v<=B).sort((a,b)=>a-b);
        const next = g_draws[i+1].filter(v => v>=A && v<=B);
        // Overlap von cur mit last
        let ov=0, p=0, q=0;
        const lastArr = Array.from(lastSet).sort((a,b)=>a-b);
        while(p<cur.length && q<lastArr.length){
          if(cur[p] === lastArr[q]) { ov++; p++; q++; }
          else if(cur[p] < lastArr[q]) p++; else q++;
        }
        if(ov >= similarityOv){
          for(const v of next){ if(v>=A && v<=B) followFreq[v]++; }
        }
      }
      // Gap‚ÄëR√ºckkehr: berechne pro Zahl durchschnittlichen Abstand und aktuelles Gap
      for(let z=A; z<=B; z++){
        const st = statsNumber[z];
        const gaps = st.gaps;
        const avgGap = gaps.length ? gaps.reduce((s,x)=>s+x,0)/gaps.length : totalDraws;
        const recency = (st.lastSeen >= 0) ? (totalDraws - 1 - st.lastSeen) : totalDraws;
        const diff = recency - avgGap;
        // positive diff ‚Üí √ºberf√§llig; negative diff ‚Üí k√ºrzlich erschienen
        st.gapScore = diff;
      }
      // Mehrere Scan-Runden (sanftes Gl√§tten / Gewichtung)
      for(let r=1; r<scanRounds; r++){
        txt($('#scanStatus'), `Gl√§tte Muster (Runde ${r+1}/${scanRounds}) ‚Ä¶`);
        const factor = 1 + r * 0.1;
        for(let z=A; z<=B; z++){
          statsNumber[z].dev       *= factor;
          statsNumber[z].pairScore *= (1 + 0.03 * r);
          followFreq[z]            *= factor;
          statsNumber[z].gapScore  *= (1 + 0.05 * r);
        }
        $('#scanProg').value = 0.9 * (r / scanRounds);
        await new Promise(r=>setTimeout(r,0));
      }
      // Score‚ÄëArrays f√ºr Normalisierung
      const arrFreq   = [];
      const arrRecent = [];
      const arrRecInv = [];
      const arrStreak = [];
      const arrPair   = [];
      const arrDevPos = [];
      const arrDevNeg = [];
      const arrFollow = [];
      const arrGap    = [];
      const tempStats = {};
      for(let z=A; z<=B; z++){
        const st = statsNumber[z];
        const recency = (st.lastSeen >= 0) ? (totalDraws - 1 - st.lastSeen) : totalDraws;
        const avgStreak = st.streaks.length ? st.streaks.reduce((s,x)=>s+x,0)/st.streaks.length : 0;
        arrFreq.push(st.freq);
        arrRecent.push(freqRecent[z]);
        arrRecInv.push(recency);
        arrStreak.push(avgStreak);
        arrPair.push(st.pairScore);
        arrDevPos.push(Math.max(0, st.dev));
        arrDevNeg.push(Math.max(0, -st.dev));
        arrFollow.push(followFreq[z]);
        arrGap.push(st.gapScore);
        tempStats[z] = {
          freq: st.freq,
          freqRecent: freqRecent[z],
          recency,
          avgStreak,
          pairScore: st.pairScore,
          dev: st.dev,
          followFreq: followFreq[z],
          gapScore: st.gapScore,
          scoreHot: 0,
          scoreCold: 0,
          scorePat: 0,
          scoreGap: 0
        };
      }
      function norm(arr, invert=false){
        const min = Math.min(...arr);
        const max = Math.max(...arr);
        if(max === min) return arr.map(()=>0);
        if(invert) return arr.map(v => (max - v) / (max - min));
        return arr.map(v => (v - min) / (max - min));
      }
      const NF      = norm(arrFreq);
      const NR      = norm(arrRecent);
      const NRecInv = norm(arrRecInv,true); // kleinere Recency = besser
      const NS      = norm(arrStreak);
      const NP      = norm(arrPair);
      const NDevPos = norm(arrDevPos);
      const NDevNeg = norm(arrDevNeg);
      const NFollow = norm(arrFollow);
      const NGap    = norm(arrGap, false);
      // Berechne Score pro Zahl f√ºr Systeme A‚ÄìD
      let idx=0;
      const candHot  = [];
      const candCold = [];
      const candPat  = [];
      const candGap  = [];
      for(let z=A; z<=B; z++){
        const sHot = 1.1*NF[idx] + 1.0*NR[idx] + 0.6*NDevPos[idx] + 0.6*NP[idx] + 0.4*NS[idx] + 0.3*NFollow[idx] + 0.4*NRecInv[idx];
        const sCold= 0.5*NF[idx] + 0.9*NDevNeg[idx] + 0.6*NRecInv[idx] + 0.4*NFollow[idx] + 0.2*NP[idx];
        const sPat = 1.2*NFollow[idx] + 0.7*NP[idx] + 0.5*NR[idx] + 0.4*NS[idx] + 0.3*NDevPos[idx];
        const sGap = 1.3*NGap[idx] + 0.6*NF[idx] + 0.5*NR[idx] + 0.3*NFollow[idx];
        tempStats[z].scoreHot    = sHot;
        tempStats[z].scoreCold   = sCold;
        tempStats[z].scorePat    = sPat;
        tempStats[z].scoreGap    = sGap;
        candHot.push({z,score:sHot});
        candCold.push({z,score:sCold});
        candPat.push({z,score:sPat});
        candGap.push({z,score:sGap});
        idx++;
      }
      // Sortiere Kandidaten nach Score
      candHot.sort((a,b) => b.score - a.score);
      candCold.sort((a,b) => b.score - a.score);
      candPat.sort((a,b) => b.score - a.score);
      candGap.sort((a,b) => b.score - a.score);
      // Helper zum Ausw√§hlen von Top¬†20
      const pickTop20 = arr => arr.slice(0,20).map(x => x.z);

      /*
        * Sanitizing der Kandidatenlisten:
        *
        * KENO‚ÄëZiehungen sind zuf√§llig„Äê820644395070059‚Ä†L224-L243„Äë, dennoch f√ºhrt das reine
        * Sortieren nach Scores mitunter zu trivialen, deterministischen S√§tzen wie
        * 1‚Äë2‚Äë3‚Äë‚Ä¶‚Äë20. Solche arithmetischen Folgen sind weder realistisch noch
        * w√ºnschenswert. Diese Funktion bereinigt eine Liste von Zahlen so,
        * dass keine Serie von mehr als MAX_RUN aufeinanderfolgenden Zahlen
        * entsteht. Ist die urspr√ºngliche Liste k√ºrzer als 20, oder werden
        * Nummern aufgrund der Run‚ÄëRegel entfernt, so wird aus einer
        * Fallback‚ÄëListe (ebenfalls nach Score sortiert) aufgef√ºllt, bis
        * wieder 20 Werte vorliegen. Zur Sicherheit wird am Ende bei Bedarf
        * komplettiert, falls immer noch zu wenige Zahlen vorhanden sind.
        */
      const MAX_RUN = 3;
      function sanitizeCandidateList(nums, fallbackList) {
        let res = [];
        const used = new Set();
        // Pr√ºft, ob das Hinzuf√ºgen von num eine zu lange Folge erzeugen w√ºrde
        function createsLongRun(arr, num){
          const tmp = arr.concat([num]).sort((a,b)=>a-b);
          for(let i=0; i<tmp.length; i++){
            let run = 1;
            for(let j=i+1; j<tmp.length; j++){
              if(tmp[j] === tmp[j-1] + 1){
                run++;
                if(run > MAX_RUN) return true;
              } else {
                break;
              }
            }
          }
          return false;
        }
        // zuerst √ºbernommene Zahlen testen
        for(const n of nums){
          if(res.length >= 20) break;
          if(used.has(n)) continue;
          if(createsLongRun(res, n)) continue;
          res.push(n);
          used.add(n);
        }
        // Fallback-Liste in flacher Form (Zahlen extrahieren)
        const fb = fallbackList.map(x => (typeof x === 'number' ? x : x.z));
        for(const n of fb){
          if(res.length >= 20) break;
          if(used.has(n)) continue;
          if(createsLongRun(res, n)) continue;
          res.push(n);
          used.add(n);
        }
        // Als letzte Instanz auff√ºllen (ohne Run-Pr√ºfung), falls noch Pl√§tze frei sind
        if(res.length < 20) {
          for(const n of fb){
            if(res.length >= 20) break;
            if(!used.has(n)) { res.push(n); used.add(n); }
          }
        }
        return res.slice(0,20);
      }
      
      // System¬†A‚ÄìD Sets
      // IDs der Sets entsprechen ihren Typen, damit sp√§tere Zuordnungen korrekt funktionieren.  
      // Jede Strategie erh√§lt ihre 20 bestbewerteten Zahlen (kein globales Deduplication‚ÄëVerfahren).
      const setA = {
        id: 'hot',
        label: 'System¬†A ‚Äì Hot/Deviation',
        description: 'Betont h√§ufige & positiv abweichende Zahlen.',
        type: 'hot',
        nums: pickTop20(candHot)
      };
      const setB = {
        id: 'cold',
        label: 'System¬†B ‚Äì Cold/Rebound',
        description: 'Betont unterrepr√§sentierte ‚ÄúCold‚Äù-Zahlen mit Rebound‚ÄëIdee.',
        type: 'cold',
        nums: pickTop20(candCold)
      };
      const setC = {
        id: 'pattern',
        label: 'System¬†C ‚Äì Pattern/Next‚ÄëDraw',
        description: 'Betont Follow‚ÄëPattern nach √§hnlichen Situationen zur letzten Ziehung.',
        type: 'pattern',
        nums: pickTop20(candPat)
      };
      const setD = {
        id: 'gap',
        label: 'System¬†D ‚Äì Gap‚ÄëR√ºckkehr',
        description: 'Betont Zahlen mit langen Pausen & typischem Abstands‚ÄëMuster (√ºberf√§llig).',
        type: 'gap',
        nums: pickTop20(candGap)
      };
      // System¬†E: Odd/Even Balance (10 Odd + 10 Even)
      // Wir sortieren die Zahlen mit Bezug auf ihren Hot‚ÄëScore und w√§hlen je
      // 10 Odd‚Äë und 10 Even‚ÄëZahlen. Sollte eine Kategorie weniger
      // als 10 Werte enthalten, f√ºllen wir aus den √ºbrigen Zahlen (nach Score)
      // auf, um stets 20 Zahlen zu liefern.
      const oddsSorted  = [];
      const evensSorted = [];
      for (const item of candHot) {
        (item.z % 2 === 1 ? oddsSorted : evensSorted).push(item);
      }
      oddsSorted.sort((a,b) => b.score - a.score);
      evensSorted.sort((a,b) => b.score - a.score);
      let oddsTop  = oddsSorted.slice(0,10).map(x => x.z);
      let evensTop = evensSorted.slice(0,10).map(x => x.z);
      const remainder = candHot.map(x=>x.z).filter(z => !oddsTop.includes(z) && !evensTop.includes(z));
      while (oddsTop.length < 10 && remainder.length) { oddsTop.push(remainder.shift()); }
      while (evensTop.length < 10 && remainder.length) { evensTop.push(remainder.shift()); }
      const numsE = oddsTop.concat(evensTop).slice(0,20);
      const setE = {
        id: 'oddeven',
        label: 'System¬†E ‚Äì Odd/Even Balance',
        description: 'Ausgewogene Kombination aus 10 geraden und 10 ungeraden Zahlen.',
        type: 'oddeven',
        nums: numsE
      };
      // System¬†F: High/Low Balance (untere H√§lfte/obere H√§lfte)
      // Wir teilen den Bereich in zwei H√§lften auf Grundlage der Mitte. Aus
      // candHot werden die jeweils besten 10 niedrigen und 10 hohen Zahlen
      // ausgew√§hlt. Sollte eine H√§lfte weniger Werte liefern, f√ºllen wir mit
      // verbleibenden Zahlen auf.
      const mid = Math.floor((A + B) / 2);
      const lowSorted  = [];
      const highSorted = [];
      for (const item of candHot) {
        (item.z <= mid ? lowSorted : highSorted).push(item);
      }
      lowSorted.sort((a,b) => b.score - a.score);
      highSorted.sort((a,b) => b.score - a.score);
      let lowTop  = lowSorted.slice(0,10).map(x => x.z);
      let highTop = highSorted.slice(0,10).map(x => x.z);
      const remFH = candHot.map(x=>x.z).filter(z => !lowTop.includes(z) && !highTop.includes(z));
      while (lowTop.length < 10 && remFH.length) { lowTop.push(remFH.shift()); }
      while (highTop.length < 10 && remFH.length) { highTop.push(remFH.shift()); }
      const numsF = lowTop.concat(highTop).slice(0,20);
      const setF = {
        id: 'highlow',
        label: 'System¬†F ‚Äì High/Low Balance',
        description: 'Ausgewogene Kombination aus niedrigen und hohen Zahlen.',
        type: 'highlow',
        nums: numsF
      };
      // System¬†G: Quadrant‚ÄëCluster (Segment mit h√∂chstem Score)
      // Wir unterteilen den Zahlenbereich in vier gleichgro√üe Quartile. F√ºr
      // jedes Quartil summieren wir die Hot‚ÄëScores der enthaltenen Zahlen und
      // w√§hlen das Quartil mit der h√∂chsten Summe. Daraus w√§hlen wir die
      // besten 20 Zahlen.
      const segSize = Math.floor((B - A + 1) / 4);
      const segments = [];
      for (let s=0; s<4; s++) {
        const segStart = A + s * segSize;
        const segEnd = (s === 3) ? B : (segStart + segSize - 1);
        let sumScore = 0;
        for (const item of candHot) {
          if (item.z >= segStart && item.z <= segEnd) sumScore += item.score;
        }
        segments.push({start: segStart, end: segEnd, sumScore});
      }
      segments.sort((a,b) => b.sumScore - a.sumScore);
      const bestSeg = segments[0];
      const segCandidates = candHot.filter(item => item.z >= bestSeg.start && item.z <= bestSeg.end);
      const numsG = segCandidates.slice(0,20).map(x => x.z);
      const setG = {
        id: 'quadrant',
        label: 'System¬†G ‚Äì Quadrant‚ÄëCluster',
        description: 'Konzentriert sich auf das aktivste Viertel des Bereichs.',
        type: 'quadrant',
        nums: numsG
      };
      // Bereinige jede Strategieliste, um triviale Folgen (z.B. 1‚Äì20) und
      // zu lange Serien zu vermeiden. F√ºr die Systeme A‚ÄìD nutzen wir
      // jeweils die zugeh√∂rige Score‚ÄëListe als Fallback. F√ºr E‚ÄìG
      // verwenden wir candHot, da diese Liste die umfassendste Auswahl
      // bietet. Anschlie√üend f√ºgen wir alle Sets zusammen. Doppelungen
      // zwischen den Systemen sind erlaubt, da jede Strategie unabh√§ngig
      // arbeitet.
      setA.nums = sanitizeCandidateList(setA.nums, candHot);
      setB.nums = sanitizeCandidateList(setB.nums, candCold);
      setC.nums = sanitizeCandidateList(setC.nums, candPat);
      setD.nums = sanitizeCandidateList(setD.nums, candGap);
      setE.nums = sanitizeCandidateList(setE.nums, candHot);
      setF.nums = sanitizeCandidateList(setF.nums, candHot);
      setG.nums = sanitizeCandidateList(setG.nums, candHot);
      g_candidateSets = [setA, setB, setC, setD, setE, setF, setG];
      // Erzeuge eine Zusammenfassung der wichtigsten Statistiken (Top‚ÄëZahlen und Paare)
      // f√ºr die Anzeige im Analyse‚ÄëBereich. Wir sortieren nach H√§ufigkeit.
      const topNums = Object.entries(statsNumber)
        .sort((a,b) => b[1].freq - a[1].freq)
        .slice(0, 10);
      const topPairs = Array.from(pairCounts.entries())
        .sort((a,b) => b[1] - a[1])
        .slice(0, 5);
      g_scanSummary = { topNums, topPairs };
      renderSummary();
      // UI aktualisieren
      $('#scanProg').value = 1;
      $('#scanProg').style.display = 'none';
      txt($('#scanStatus'), 'Scan abgeschlossen. ' + g_candidateSets.length + '¬†Kandidatens√§tze berechnet.');
      renderCandidateSets();

    }
    // Deduplicate: entfernt Zahlen, die bereits in vorangehenden S√§tzen vorkommen, und f√ºllt mit weiteren Zahlen aus sortierter Liste
    function deduplicateSets(setList, allSorted){
      const used = new Set();
      const result = [];
      for(const s of setList){
        const orig = allSorted[s.id] || s.nums.slice();
        const unique = [];
        for(const z of s.nums){
          if(!used.has(z)) { unique.push(z); used.add(z); }
        }
        // Falls weniger als 20, aus orig weitere Zahlen erg√§nzen
        let idx = 0;
        while(unique.length < 20 && idx < orig.length){
          const z = orig[idx++];
          if(!used.has(z)) { unique.push(z); used.add(z); }
        }
        s.nums = unique;
        result.push(s);
      }
      return result;
    }
    // Kandidatens√§tze rendern
    function renderCandidateSets(){
      const sec = $('#candidatesSection');
      const wrap = $('#candGroups');
      wrap.innerHTML = '';
      if(!g_candidateSets || !g_candidateSets.length){ sec.style.display = 'none'; return; }
      sec.style.display = '';
      for(const set of g_candidateSets){
        const box = el('div','top-group');
        const header = el('div','top-header');
        const left = el('div');
        const title = el('div');
        title.innerHTML = `<strong>${set.label}</strong>`;
        const desc  = el('div','hint');
        desc.textContent = set.description;
        left.appendChild(title);
        left.appendChild(desc);
        const right = el('label','hint');
        right.style.display = 'inline-flex';
        right.style.alignItems = 'center';
        right.style.gap = '4px';
        const cb = el('input');
        cb.type = 'checkbox';
        cb.checked = true;
        cb.dataset.setId = set.id;
        right.appendChild(cb);
        right.appendChild(document.createTextNode('f√ºr Varianten nutzen'));
        header.appendChild(left);
        header.appendChild(right);
        const list = el('div','top-list');
        set.nums.forEach(num => {
          const chip = el('span','top-number');
          chip.textContent = num;
          list.appendChild(chip);
        });
        box.appendChild(header);
        box.appendChild(list);
        wrap.appendChild(box);
      }
    }
    // Helper: welche Sets sind ausgew√§hlt
    function getSelectedSets(){
      const selected = [];
      const cbList = document.querySelectorAll('input[type="checkbox"][data-set-id]');
      const byId = new Map(g_candidateSets.map(s => [s.id,s]));
      cbList.forEach(cb => { if(cb.checked){ const s = byId.get(cb.dataset.setId); if(s) selected.push(s); } });
      return selected;
    }
    // Varianten erzeugen
    $('#genBtn').addEventListener('click', () => { try { generateVariants(); } catch(e){ console.error(e); } });
    $('#clearVarBtn').addEventListener('click', () => {
      g_variantsBySet = {};
      $('#varBlocks').innerHTML = '';
      txt($('#varStatus'),'Varianten gel√∂scht.');
      $('#compareResults').innerHTML = '';
      $('#compareStatus').textContent = '';
    });
    function generateVariants(){
      if(!g_candidateSets || !g_candidateSets.length){ txt($('#varStatus'),'Bitte zuerst scannen.'); return; }
      const selectedSets = getSelectedSets();
      if(!selectedSets.length){ txt($('#varStatus'),'Bitte mindestens einen Satz ausw√§hlen.'); return; }
      const S = parseInt($('#kenoType').value,10);
      const want = Math.max(1, parseInt($('#numVariants').value,10) || 1);
      const ovLim = Math.max(0, parseInt($('#overlapLimit').value,10) || 0);
      if(!S || S < 1){ txt($('#varStatus'),'Ung√ºltiger Keno‚ÄëTyp.'); return; }
      g_variantsBySet = {};
      const blockWrap = $('#varBlocks');
      blockWrap.innerHTML = '';
      const hasLongRun = arr => {
        let run=1;
        for(let i=1; i<arr.length; i++){
          if(arr[i] === arr[i-1]+1){ run++; if(run>=4) return true; }
          else run=1;
        }
        return false;
      };
      const computeOverlap = (a,b) => {
        let ov=0,i=0,j=0;
        while(i<a.length && j<b.length){ if(a[i]===b[j]){ ov++; i++; j++; } else if(a[i]<b[j]) i++; else j++; }
        return ov;
      };
      for(const set of selectedSets){
        const pool = set.nums.slice();
        const results = [];
        const seen = new Set();
        let attempts=0;
        const maxAttempts = want * 500;
        while(results.length < want && attempts < maxAttempts){
          attempts++;
          const shuffled = pool.slice().sort(() => Math.random() - 0.5);
          const variant  = shuffled.slice(0,S).sort((a,b)=>a-b);
          if(hasLongRun(variant)) continue;
          const key = variant.join(',');
          if(seen.has(key)) continue;
          if(ovLim > 0){ let ok=true; for(const v of results){ if(computeOverlap(v.numbers, variant) > ovLim){ ok=false; break; } } if(!ok) continue; }
          results.push({numbers:variant, hist:null});
          seen.add(key);
        }
        g_variantsBySet[set.id] = results;
        const block = el('div','variants-block');
        const head  = el('div','flex-between');
        const t1    = el('div'); t1.innerHTML = `<strong>${set.label}</strong>`;
        const t2    = el('div','hint'); t2.textContent = `${results.length}¬†Varianten generiert.`;
        head.appendChild(t1); head.appendChild(t2);
        block.appendChild(head);
        const list = el('div','mt-2');
        results.forEach((v,idx) => {
          const row = el('div','variant-item');
          row.textContent = `#${String(idx+1).padStart(2,'0')}¬†¬†${v.numbers.join(' ')}`;
          list.appendChild(row);
        });
        block.appendChild(list);
        blockWrap.appendChild(block);
      }
      const totalVar = Object.values(g_variantsBySet).reduce((s,arr) => s + arr.length, 0);
      txt($('#varStatus'), `${totalVar}¬†Varianten √ºber ${selectedSets.length}¬†S√§tze erzeugt.`);
      $('#compareResults').innerHTML = '';
      $('#compareStatus').textContent = '';
    }
    // Vergleich mit Archiv
    $('#compareBtn').addEventListener('click', () => {
      compareVariants().catch(err => console.error(err));
    });
    async function compareVariants(){
      if(!g_draws || !g_draws.length){ txt($('#compareStatus'),'Bitte zuerst ein Archiv laden.'); return; }
      const S = parseInt($('#kenoType').value,10);
      if(!S || S < 1){ txt($('#compareStatus'),'Ung√ºltiger Keno‚ÄëTyp.'); return; }
      const setIds = Object.keys(g_variantsBySet);
      if(!setIds.length){ txt($('#compareStatus'),'Bitte zuerst Varianten erzeugen.'); return; }
      const totalVariants = Object.values(g_variantsBySet).reduce((s,arr) => s + arr.length, 0);
      if(!totalVariants){ txt($('#compareStatus'),'Keine Varianten zum Vergleichen.'); return; }
      $('#compareProg').style.display = '';
      $('#compareProg').value = 0;
      txt($('#compareStatus'), 'Vergleiche Varianten mit Archiv ‚Ä¶');
      const totalDraws = g_draws.length;
      let processed = 0;
      // Pre‚ÄëSort draws
      const sortedDraws = g_draws.map(dr => dr.slice().sort((a,b)=>a-b));
      for(const setId of setIds){
        const arr = g_variantsBySet[setId];
        for(const v of arr){
          const hist = {};
          for(let k=0; k<=S; k++) hist[k] = 0;
          const variant = v.numbers;
          const lenV = variant.length;
          for(let i=0; i<totalDraws; i++){
            const d = sortedDraws[i];
            let ov=0,p=0,q=0;
            while(p<lenV && q<d.length){ if(variant[p] === d[q]){ ov++; p++; q++; } else if(variant[p] < d[q]) p++; else q++; }
            if(ov > S) ov = S;
            hist[ov] = (hist[ov] || 0) + 1;
          }
          v.hist = hist;
          processed++;
          if(processed % 5 === 0){ $('#compareProg').value = processed / totalVariants; await new Promise(r=>setTimeout(r,0)); }
        }
      }
      $('#compareProg').value = 1;
      $('#compareProg').style.display = 'none';
      txt($('#compareStatus'),'Vergleich abgeschlossen.');
      renderCompareResults(S);
    }
    function renderCompareResults(S){
      const wrap = $('#compareResults');
      wrap.innerHTML = '';
      const sets = g_candidateSets.filter(s => g_variantsBySet[s.id] && g_variantsBySet[s.id].length);
      for(const set of sets){
        const arr = g_variantsBySet[set.id];
        if(!arr.length) continue;
        const box = el('div','variants-block');
        const head = el('div','flex-between');
        const t1   = el('div'); t1.innerHTML = `<strong>${set.label}</strong>`;
        const t2   = el('div','hint'); t2.textContent = `${arr.length}¬†Varianten ¬∑ Treffer 0‚Ä¶${S} √ºber ${g_draws.length}¬†Ziehungen`;
        head.appendChild(t1); head.appendChild(t2);
        box.appendChild(head);
        const table = el('table','compare-table');
        const thead = el('thead');
        const trh = el('tr');
        trh.appendChild(th('Var.'));
        for(let k=S; k>=0; k--){ trh.appendChild(th(`${k}/${S}`)); }
        thead.appendChild(trh);
        table.appendChild(thead);
        const tbody = el('tbody');
        arr.forEach((v,idx)=>{
          const tr = el('tr');
          tr.appendChild(td('#'+String(idx+1).padStart(2,'0')));
          for(let k=S; k>=0; k--){ const val = (v.hist && v.hist[k]) || 0; tr.appendChild(td(val.toString())); }
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        box.appendChild(table);
        wrap.appendChild(box);
      }
      function th(text){ const x = document.createElement('th'); x.textContent = text; return x; }
      function td(text){ const x = document.createElement('td'); x.textContent = text; return x; }
    }

    // Analysestatistik anzeigen
    function renderSummary(){
      const sec = $('#summarySection');
      const cont = $('#summaryContent');
      if(!g_scanSummary){
        sec.style.display = 'none';
        return;
      }
      sec.style.display = '';
      cont.innerHTML = '';
      // Top‚ÄëZahlen
      const topDiv = el('div','mt-2');
      const title1 = el('div');
      title1.innerHTML = '<strong>Top¬†10 Zahlen (H√§ufigkeit)</strong>';
      topDiv.appendChild(title1);
      const list1 = el('div','top-list');
      g_scanSummary.topNums.forEach(([num, obj]) => {
        const chip = el('span','top-number');
        chip.textContent = num + ' (' + obj.freq + ')';
        list1.appendChild(chip);
      });
      topDiv.appendChild(list1);
      cont.appendChild(topDiv);
      // Top‚ÄëPaare
      const pairDiv = el('div','mt-2');
      const title2 = el('div');
      title2.innerHTML = '<strong>Top¬†5 Paare (gemeinsame Ziehungen)</strong>';
      pairDiv.appendChild(title2);
      const list2 = el('div','top-list');
      g_scanSummary.topPairs.forEach(([key, count]) => {
        const chip = el('span','top-number');
        chip.textContent = key + ' (' + count + ')';
        list2.appendChild(chip);
      });
      pairDiv.appendChild(list2);
      cont.appendChild(pairDiv);
    }
  })();
  </script>
</body>
</html>