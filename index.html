<!doctype html>
<!--
  KENO Analyse-Tool
  Dieses Tool lädt ein KENO-Archiv (CSV/TXT/ZIP), analysiert die Ziehungen
  auf vielfältige Muster und erstellt daraus eine heuristische Top‑20‑Liste
  möglicher Kandidaten für die nächste Ziehung. Anschließend können aus
  diesen Kandidaten Varianten entsprechend dem gewählten KENO‑Typ generiert
  werden. Alle Berechnungen geschehen komplett im Browser und sind rein
  statistischer Natur – es gibt keine Gewinngarantie.
-->
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>KENO Analyse‑Tool</title>
  <!-- JSZip zum Entpacken von ZIP‑Archiven -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    :root {
      /* Dunkles Farbschema mit neonartigen Akzenten */
      --bg: #0a1128;
      --panel: #14213d;
      --border: #1f2a54;
      --text: #e1e9ff;
      --accent: #00f5a0;
      --accent2: #00bbf9;
      --danger: #f43f5e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 16px;
      font-family: ui-monospace, Consolas, Menlo, monospace;
      background: linear-gradient(135deg, var(--bg), #100c2d 50%, var(--bg));
      color: var(--text);
    }
    h1, h2, h3 {
      margin-top: 0;
      color: var(--accent);
      text-shadow: 0 0 4px var(--accent2), 0 0 8px var(--accent);
    }
    .container { max-width: 1000px; margin: 0 auto; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    label { display: block; margin: 6px 0 4px; }
    input[type="number"], input[type="text"], select, button {
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
    }
    button {
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s, transform 0.2s;
    }
    button.primary {
      background: linear-gradient(135deg, #059669, #22c55e);
      color: #04110a;
    }
    button.primary:hover { background: linear-gradient(135deg, #06b981, #34d58c); transform: translateY(-1px); }
    button.danger { background: #7f1d1d; border-color: #991b1b; color: #fee2e2; }
    button.danger:hover { background: #991b1b; transform: translateY(-1px); }
    progress {
      width: 100%;
      height: 12px;
      border-radius: 8px;
      background: var(--bg);
      border: 1px solid var(--border);
      overflow: hidden;
    }
    progress::-webkit-progress-bar { background: var(--bg); }
    progress::-webkit-progress-value { background: var(--accent); }
    .top-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 6px;
      border-bottom: 1px solid var(--border);
    }
    .variant-item {
      padding: 4px 6px;
      border-bottom: 1px solid var(--border);
      font-family: ui-monospace, Consolas, Menlo, monospace;
    }
    .hint { font-size: 0.85em; color: #9ca3af; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>KENO Analyse‑Tool</h1>
    <!-- Archiv laden -->
    <div class="panel">
      <h2>Archiv laden</h2>
      <label for="file">CSV/TXT/ZIP auswählen</label>
      <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
      <div id="status" class="hint">Kein Archiv geladen.</div>
    </div>
    <!-- Einstellungen -->
    <div class="panel">
      <h2>Einstellungen</h2>
      <div class="row">
        <label for="kenoType">Keno‑Typ (Anzahl Zahlen pro Tipp)</label>
        <select id="kenoType">
          <option value="2">Typ 2</option>
          <option value="3">Typ 3</option>
          <option value="4">Typ 4</option>
          <option value="5">Typ 5</option>
          <option value="6" selected>Typ 6</option>
          <option value="7">Typ 7</option>
          <option value="8">Typ 8</option>
          <option value="9">Typ 9</option>
          <option value="10">Typ 10</option>
        </select>
      </div>
      <div class="row">
        <label for="rangeFrom">Zahlenbereich: von</label>
        <input type="number" id="rangeFrom" value="1" min="1" max="200">
      </div>
      <div class="row">
        <label for="rangeTo">Zahlenbereich: bis</label>
        <input type="number" id="rangeTo" value="70" min="1" max="200">
      </div>
      <div class="row">
        <label for="numVariants">Variantenanzahl</label>
        <input type="number" id="numVariants" value="10" min="1" max="200">
      </div>
    </div>
    <!-- Scan & Analyse -->
    <div class="panel">
      <h2>Scannen &amp; Analyse</h2>
      <button id="scanBtn" class="primary">Scannen</button>
      <progress id="scanProg" value="0" max="1" style="display:none"></progress>
      <div id="scanStatus" class="hint"></div>
      <div id="topSection" style="display:none; margin-top: 12px;">
        <h3>Top 20 Kandidaten</h3>
        <div class="hint">Basierend auf Musteranalyse – keine Gewinngarantie!</div>
        <div id="topList"></div>
      </div>
    </div>
    <!-- Varianten -->
    <div class="panel" id="varPanel" style="display:none">
      <h2>Varianten generieren</h2>
      <button id="genBtn" class="primary">Varianten aus Top 20 generieren</button>
      <div id="varStatus" class="hint"></div>
      <div id="variantsList" style="margin-top: 12px;"></div>
    </div>
  </div>
  <script>
  (function(){
    'use strict';
    const fileInput = document.getElementById('file');
    const statusEl = document.getElementById('status');
    const scanBtn = document.getElementById('scanBtn');
    const scanProg = document.getElementById('scanProg');
    const scanStatus = document.getElementById('scanStatus');
    const topSection = document.getElementById('topSection');
    const topList = document.getElementById('topList');
    const genBtn = document.getElementById('genBtn');
    const variantsList = document.getElementById('variantsList');
    const varPanel = document.getElementById('varPanel');
    const varStatus = document.getElementById('varStatus');
    // Globale Variablen für Archiv und Ergebnisse
    let g_draws = [];
    let g_drawSize = 0;
    let g_scores = null;
    let g_topNumbers = null;
    let g_stats = null;
    // Helfer: nummerische Eingabewerte lesen
    function getInt(id){ return parseInt(document.getElementById(id).value, 10) || 0; }
    // Anzeige aktualisieren
    function setStatus(txt){ statusEl.textContent = txt; }
    // Archiv laden und parsen
    fileInput.addEventListener('change', async (ev) => {
      const file = ev.target.files[0];
      if(!file){ setStatus('Keine Datei ausgewählt.'); return; }
      try {
        if(file.name.toLowerCase().endsWith('.zip')){
          await loadZip(file);
        } else {
          const text = await file.text();
          parseArchive(text);
        }
      } catch(err){
        console.error(err);
        setStatus('Fehler beim Laden: ' + err.message);
      }
    });
    // ZIP laden mit JSZip
    async function loadZip(file){
      setStatus('Entpacke ZIP …');
      const zip = await JSZip.loadAsync(file);
      // Suche nach der ersten Text- oder CSV-Datei
      let found = null;
      zip.forEach((relPath, zipEntry) => {
        if(!found && !zipEntry.dir && /\.(txt|csv)$/i.test(zipEntry.name)){
          found = zipEntry;
        }
      });
      if(!found){ setStatus('Keine geeignete Datei im ZIP gefunden.'); return; }
      const raw = await found.async('string');
      parseArchive(raw);
    }
    // Archiv-Text parsen und g_draws befüllen
    function parseArchive(raw){
      const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const draws = [];
      for(const ln of lines){
        // Headerzeilen mit "Zahl" überspringen
        if(/zahl\s*1/i.test(ln)) continue;
        // Alle Ziffern extrahieren
        const numsRaw = ln.match(/\d+/g);
        if(!numsRaw) continue;
        // Wenn weniger als 5 Zahlen, ignoriere
        if(numsRaw.length < 5) continue;
        const nums = numsRaw.map(x => parseInt(x,10));
        draws.push(nums);
      }
      if(!draws.length){ setStatus('Keine gültigen Ziehungen gefunden.'); return; }
      g_draws = draws;
      g_drawSize = draws[0].length;
      setStatus(draws.length + ' Ziehungen geladen (Größe ' + g_drawSize + ').');
      // Nach Ladevorgang alte Ergebnisse zurücksetzen
      scanStatus.textContent = '';
      topSection.style.display = 'none';
      varPanel.style.display = 'none';
      g_scores = null;
      g_topNumbers = null;
      g_stats = null;
    }
    // Hauptfunktion zum Scannen
    async function scan(){
      if(!g_draws || !g_draws.length){ scanStatus.textContent = 'Bitte zuerst ein Archiv laden.'; return; }
      const A = getInt('rangeFrom');
      const B = getInt('rangeTo');
      if(isNaN(A) || isNaN(B) || A > B){ scanStatus.textContent = 'Ungültiger Zahlenbereich.'; return; }
      scanProg.value = 0;
      scanProg.style.display = '';
      scanStatus.textContent = 'Scan gestartet …';
      // Initialisiere Statistiken
      const statsNumber = {};
      for(let z = A; z <= B; z++){
        statsNumber[z] = {
          freq: 0,
          lastSeen: -1,
          currentStreak: 0,
          longestStreak: 0,
          streaks: [],
          gaps: [],
          pairScore: 0,
        };
      }
      const pairCounts = new Map();
      const tripleCounts = new Map();
      const overlapHist = {};
      let prevSorted = null;
      const total = g_draws.length;
      // Schleife über alle Ziehungen
      for(let i=0; i< total; i++){
        const draw = g_draws[i];
        // sortierte Zahlen im gültigen Bereich
        const sorted = draw.filter(x => x >= A && x <= B).sort((a,b) => a-b);
        // Aktualisiere Zahlenstatistik
        for(const v of sorted){
          const st = statsNumber[v];
          st.freq += 1;
          // Streak berechnen
          if(st.lastSeen === i-1){ st.currentStreak += 1; }
          else {
            if(st.currentStreak > 0) st.streaks.push(st.currentStreak);
            st.currentStreak = 1;
          }
          // Gap zum vorherigen Auftreten
          if(st.lastSeen >= 0){ st.gaps.push(i - st.lastSeen); }
          st.lastSeen = i;
        }
        // Paar- und Triplezählung
        const n = sorted.length;
        for(let a = 0; a < n; a++){
          const vA = sorted[a];
          for(let b = a+1; b < n; b++){
            const vB = sorted[b];
            const key2 = vA + '-' + vB;
            pairCounts.set(key2, (pairCounts.get(key2) || 0) + 1);
            statsNumber[vA].pairScore += 1;
            statsNumber[vB].pairScore += 1;
            for(let c = b+1; c < n; c++){
              const vC = sorted[c];
              const key3 = key2 + '-' + vC;
              tripleCounts.set(key3, (tripleCounts.get(key3) || 0) + 1);
              statsNumber[vA].pairScore += 1;
              statsNumber[vB].pairScore += 1;
              statsNumber[vC].pairScore += 1;
            }
          }
        }
        // Overlap zum vorherigen Draw
        if(prevSorted){
          let ov = 0;
          let p = 0, q = 0;
          while(p < prevSorted.length && q < sorted.length){
            if(prevSorted[p] === sorted[q]){ ov++; p++; q++; }
            else if(prevSorted[p] < sorted[q]) p++; else q++;
          }
          overlapHist[ov] = (overlapHist[ov] || 0) + 1;
        }
        prevSorted = sorted;
        // Progress anzeigen
        if((i+1) % 50 === 0){
          scanProg.value = (i+1)/total;
          scanStatus.textContent = 'Scanne Archiv… ' + Math.floor((i+1)/total*100) + '%';
          await new Promise(r => setTimeout(r, 0));
        }
      }
      // Abschluss: offene Streaks beenden
      for(let z = A; z <= B; z++){
        const st = statsNumber[z];
        if(st.currentStreak > 0) st.streaks.push(st.currentStreak);
        st.longestStreak = Math.max(0, ...st.streaks);
      }
      // Berechne Häufigkeit der letzten 50 Ziehungen
      const recentWindow = 50;
      const freqRecent = {};
      const startRecent = Math.max(0, total - recentWindow);
      for(let z = A; z <= B; z++) freqRecent[z] = 0;
      for(let i = startRecent; i < total; i++){
          const draw = g_draws[i];
          for(const v of draw){ if(v >= A && v <= B) freqRecent[v] += 1; }
      }
      // Berechne Score für jede Zahl
      const values = { freq: [], recent: [], recency: [], streak: [], pair: [], gapBonus: [] };
      const tempStats = {};
      // Sammle Raw-Werte
      for(let z = A; z <= B; z++){
        const st = statsNumber[z];
        const recency = (st.lastSeen >= 0) ? (total - 1 - st.lastSeen) : total;
        const avgStreak = st.streaks.length ? st.streaks.reduce((s,x) => s+x, 0) / st.streaks.length : 0;
        // Gap-Bonus vorbereiten
        let gapBonus = 0;
        if(st.gaps.length >= 2){
          // Finde häufigsten Gap
          const gc = {};
          let maxGapCount = 0, topGap = 0;
          for(const g of st.gaps){ gc[g] = (gc[g] || 0) + 1; if(gc[g] > maxGapCount){ maxGapCount = gc[g]; topGap = g; } }
          const lastGap = st.gaps[st.gaps.length - 1];
          const diff = Math.abs(lastGap - topGap);
          // Gewichtung: wie dominant ist das Top-Gap + wie nahe ist lastGap am Top-Gap
          const dominance = maxGapCount / st.gaps.length;
          const closeness = 1 - Math.min(diff / (topGap * 2), 1);
          gapBonus = dominance * closeness;
        }
        values.freq.push(st.freq);
        values.recent.push(freqRecent[z]);
        values.recency.push(recency);
        values.streak.push(avgStreak);
        values.pair.push(st.pairScore);
        values.gapBonus.push(gapBonus);
        tempStats[z] = { freq: st.freq, freqRecent: freqRecent[z], recency, avgStreak, pairScore: st.pairScore, gapBonus };
      }
      // Normieren
      function normArr(arr, invert=false){
        const min = Math.min(...arr);
        const max = Math.max(...arr);
        if(max === min) return arr.map(() => 0);
        return arr.map(v => invert ? (max - v) / (max - min) : (v - min) / (max - min));
      }
      const normFreq = normArr(values.freq);
      const normRecent = normArr(values.recent);
      const normRecency = normArr(values.recency, false); // kleiner recency = kürzlich gezogen, soll höheren Score geben
      const normStreak = normArr(values.streak);
      const normPair = normArr(values.pair);
      const normGap = normArr(values.gapBonus);
      // Gewichte für die Score-Berechnung
      const w = { freq: 1.0, recent: 1.0, recency: 0.5, streak: 0.5, pair: 0.5, gap: 0.7 };
      // Score zusammenstellen
      g_scores = {};
      g_topNumbers = [];
      let idx = 0;
      for(let z = A; z <= B; z++){
        const score = 
          w.freq * normFreq[idx] +
          w.recent * normRecent[idx] +
          w.recency * (1 - normRecency[idx]) + // invertiert: kurze Recency = höherer Score
          w.streak * normStreak[idx] +
          w.pair * normPair[idx] +
          w.gap * normGap[idx];
        g_scores[z] = score;
        tempStats[z].score = score;
        idx++;
      }
      // Sortiere Top 20
      const allNums = Object.keys(g_scores).map(n => parseInt(n,10));
      allNums.sort((a,b) => g_scores[b] - g_scores[a]);
      g_topNumbers = allNums.slice(0, 20);
      // Speichere Statistiken global für später (z.B. Varianten)
      g_stats = tempStats;
      // UI ausgeben
      scanProg.value = 1;
      scanProg.style.display = 'none';
      scanStatus.textContent = 'Scan abgeschlossen. Top 20 erstellt.';
      renderTopList();
      varPanel.style.display = 'block';
    }
    function renderTopList(){
      topSection.style.display = '';
      topList.innerHTML = '';
      for(let i=0; i<g_topNumbers.length; i++){
        const z = g_topNumbers[i];
        const st = g_stats[z];
        const div = document.createElement('div');
        div.className = 'top-item';
        div.innerHTML =
          '<span><strong>#' + String(i+1).padStart(2,'0') + '</strong> ' + z + '</span>' +
          '<span>Score: ' + st.score.toFixed(3) + ' · Häufig: ' + st.freq + ' · Letzte: ' + st.recency + '</span>';
        topList.appendChild(div);
      }
    }
    // Varianten generieren
    function generateVariants(){
      if(!g_topNumbers || g_topNumbers.length === 0){ varStatus.textContent = 'Bitte zuerst scannen.'; return; }
      const S = getInt('kenoType');
      const want = getInt('numVariants');
      if(!S || S < 1){ varStatus.textContent = 'Ungültiger Keno-Typ.'; return; }
      const results = [];
      // Zähle, wie oft jede Zahl benutzt wurde
      const used = {};
      for(const z of g_topNumbers) used[z] = 0;
      const penaltyFactor = 0.1;
      let attempts = 0;
      while(results.length < want && attempts < want * 10){
        attempts++;
        const variant = [];
        while(variant.length < S){
          // sortiere Kandidaten nach Score-Penalty
          const candidates = g_topNumbers.filter(z => !variant.includes(z));
          candidates.sort((a,b) => (g_scores[b] - penaltyFactor * used[b]) - (g_scores[a] - penaltyFactor * used[a]));
          const pick = candidates[0];
          variant.push(pick);
        }
        variant.sort((a,b) => a - b);
        // einfache Regel: keine 3 direkt aufeinanderfolgenden Zahlen
        let hasRun = false;
        for(let i=0; i<variant.length-2; i++){
          if(variant[i+2] - variant[i] === 2){ hasRun = true; break; }
        }
        if(hasRun) continue;
        // check duplicate variant
        const key = variant.join(',');
        if(results.some(v => v.join(',') === key)) continue;
        results.push(variant);
        for(const v of variant) used[v] += 1;
      }
      // Ausgabe
      variantsList.innerHTML = '';
      if(results.length === 0){ variantsList.textContent = 'Keine gültigen Varianten gefunden.'; return; }
      results.forEach((arr,i) => {
        const div = document.createElement('div');
        div.className = 'variant-item';
        div.textContent = '#' + String(i+1).padStart(2,'0') + '  ' + arr.join(' ');
        variantsList.appendChild(div);
      });
      varStatus.textContent = results.length + ' Varianten generiert.';
    }
    // Event-Handler
    scanBtn.addEventListener('click', scan);
    genBtn.addEventListener('click', generateVariants);
  })();
  </script>
</body>
</html>