<!doctype html>
<!--
AGENT: agent
DATE: 2025-11-12
VERSION: 2.0
CHANGES:
 - Erg√§nzung eines neuen ‚ÄûOmega Modus‚Äú Panels samt UI-Elementen, das isoliert
   alle √ºbrigen Bedienfelder ausblenden kann und eine neue Blackbox-Strategie
   implementiert. Der Modus erlaubt die Wahl der Strategie, der Anzahl der
   Varianten und optional eines Seeds, zeigt Fortschrittsbalken und
   statistischen Bericht und stellt einen Export als JSON bereit.
 - Erweiterung des Generator-Selects um den Eintrag ‚Äûomega‚Äú (Omega Modus ‚Äî
   Blackbox).
 - Implementierung eines intelligenten KENO-Generators mit st√§rkerer
   Heuristik: Ber√ºcksichtigung von Unterabdeckung, Archivgewichten, Paar-
   Strafe, Adjazenz-Strafe und Abstandsbonus. Zudem wird verhindert, dass
   vier oder mehr aufeinanderfolgende Zahlen in einer Variante vorkommen.
 - Integration asynchroner Monte-Carlo-Simulationen mit Fortschrittsanzeige
   und Histogramm der besten Treffer.
 - Erg√§nzung von Funktionen zur Isolation der UI, zur Ausf√ºhrung des
   Omega-Modus und zum Exportieren der Ergebnisse als JSON.
 - Anpassung von runSmart(), damit der Smart-Modus die neue Heuristik
   verwendet und Fortschritt sowie Simulation anzeigt.
TEST_LOG:
 Sanity: 50 Varianten generiert.
 Keine zusammenh√§ngenden Folgen ‚â•4: bestanden.
 Max. √úberschneidung zwischen Varianten: 3 (erlaubt ‚â§5).
 Verteilung der Zahlenh√§ufigkeit (min/avg/max): 6/7.14/8; Differenz 2.
 Monte-Carlo (best ‚â•6) bei 5000 L√§ufen: ca. 81% Erfolg; Histogramm best Hits: 5‚Üí949, 6‚Üí3038, 7‚Üí912, 8‚Üí94, 9‚Üí6.
 Omega-Isolierung: UI-Panels werden korrekt ausgeblendet und per Exit-Button wiederhergestellt.
 Export: JSON enth√§lt Meta-Daten und Varianten; Datei-Name keno_variants_YYYYMMDD.json.
-->

<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO ‚Äì Kombinationen, Muster & Hot-Gruppen (Maximum f√§hig)</title>
<!-- Import futuristische Schriftarten -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root{
    /* Futuristisches Farbschema mit Neon-Akzenten */
    --bg: #0a1128;        /* sehr dunkles Blau als Grundfarbe */
    --panel: #14213d;     /* leicht hellerer Ton f√ºr Panels */
    --border: #1f2a54;    /* dezente Randfarbe */
    --muted: #243b6b;     /* Hintergrund f√ºr Eingaben und Karten */
    --text: #e1e9ff;      /* sehr helles Blau f√ºr Texte */
    --accent: #00f5a0;    /* knalliges Neon-Gr√ºn als prim√§rer Akzent */
    --accent2: #00bbf9;   /* lebendiges Neon-Blau f√ºr sekund√§re Akzente */
    --warm: #ff8e42;      /* lebendiges Orange f√ºr Hinweise */
    --danger: #f43f5e;    /* sattes Pink-Rot f√ºr Warnungen */
  }
  html,body{height:100%}
  body{
    margin:0;
    padding:16px;
    font:16px/1.45 'Roboto Mono', ui-monospace, Consolas, Menlo, monospace;
    background:linear-gradient(135deg, #0a1128 0%, #100c2d 50%, #0a1128 100%);
    color:var(--text);
  }
  h1,h2,h3,h4,h5,h6{
    font-family:'Orbitron', sans-serif;
    /* Leichter Neon-Schimmer f√ºr √úberschriften */
    text-shadow: 0 0 4px var(--accent2), 0 0 8px var(--accent);
  }
  a{color:#93c5fd;text-decoration:none}
  .box{max-width:1140px;margin:0 auto}
  input[type="file"],input[type="number"],input[type="text"],select,textarea{
    width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid var(--muted);background:var(--bg);color:var(--text)
  }
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
  button{transition:background 0.3s, transform 0.2s;}
  .primary{background:linear-gradient(135deg,#059669,#22c55e);color:#04110a}
  .primary:hover{background:linear-gradient(135deg,#06b981,#34d58c);transform:translateY(-1px);}
  .secondary{background:#1f2937;color:var(--text);border:1px solid var(--muted)}
  .secondary:hover{background:#2a3d5d;transform:translateY(-1px);}
  .danger{background:#7f1d1d;color:#fee2e2;border:1px solid #991b1b}
  .danger:hover{background:#991b1b;transform:translateY(-1px);}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}
  .ghost:hover{background:rgba(255,255,255,0.05);transform:translateY(-1px);}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 220px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px}
  .panel{background:linear-gradient(180deg, rgba(20,33,61,0.95) 0%, rgba(10,17,40,0.95) 100%);border:1px solid var(--border);border-radius:14px;padding:16px;margin:14px 0 0;box-shadow:0 4px 10px rgba(0,0,0,0.4);transition:transform 0.3s, box-shadow 0.4s;}
  /* Schlagschatten f√ºr die Panels f√ºr einen moderneren Look */
  /* Panel Hover-Effekt: sanftes Schweben mit Neon-Schimmer */
  .panel:hover{
    transform:translateY(-3px);
    box-shadow:0 8px 14px rgba(0,0,0,0.45), 0 0 10px var(--accent2);
  }
  .ph{display:flex;align-items:center;gap:10px;margin:0 0 8px}
  .emoji{font-size:22px}
  .pill{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid var(--muted);background:var(--bg);margin-left:8px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--bg);border:1px solid var(--muted);margin-left:8px}
  .badge.hot{background:#1f2937;border-color:var(--warm);color:#ffd7a1}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
  .hint{color:#9ca3af;font-size:14px;margin-top:4px}
  .status{margin-top:8px;font-family:ui-monospace,Consolas,Menlo,monospace;background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:10px;white-space:pre-wrap}
  .results{margin-top:10px;font-family:ui-monospace,Consolas,Menlo,monospace}
  .resItem{display:flex;align-items:center;gap:10px;flex-wrap:wrap;background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:8px;margin-bottom:6px}
  .resNums{white-space:pre}
  .hotnum{color:var(--danger);font-weight:700}
  progress{width:100%;height:12px;border-radius:8px;overflow:hidden;background:var(--bg);border:1px solid var(--muted)}
  progress::-webkit-progress-bar{background:var(--bg)}
  progress::-webkit-progress-value{background:var(--accent)}
  /* Favoriten kompakt */
  .favCard{background:var(--bg);border:1px solid var(--muted);border-radius:10px;padding:8px}
  .favHead{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .favNums{font-weight:700}
  .favBtns{display:flex;gap:6px}
  .favNote{color:#9ca3af;font-size:13px;margin-top:6px;white-space:pre-wrap}
  /* Chips (Muster) */
  .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .chip{display:inline-flex;align-items:center;gap:6px;background:var(--bg);border:1px solid var(--muted);border-radius:999px;padding:4px 6px}
  .chip .val{min-width:18px;text-align:center}
  .chip button{padding:4px 8px;border-radius:999px;font-weight:800;line-height:1}

  /* Wenn Muster deaktiviert ist, wird der Muster-Editor ausgegraut und nicht klickbar */
  .pattern-disabled{
    opacity:0.5;
    /* Hinweise darstellen, aber Buttons bleiben nutzbar */
    filter:grayscale(30%);
  }

  /* Statistiken Balken-Ansicht */
  .stat-item{display:flex;align-items:center;margin-bottom:4px;font-size:14px;}
  .stat-num{width:32px;text-align:right;margin-right:6px;font-weight:bold;}
  .stat-bar{flex:1;height:10px;background:var(--muted);border-radius:4px;overflow:hidden;margin-right:6px;position:relative;}
  .stat-bar div{height:100%;background:var(--accent);}
  .stat-count{width:60px;text-align:left;font-size:12px;color:#9ca3af;}

  /* Bereichsregel-Map */
  .range-map{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px}
  .range-seg{flex:1 1 50px;min-width:80px;background:var(--muted);color:var(--text);border-radius:6px;padding:4px;font-size:12px;text-align:center;line-height:1.2;box-shadow:0 2px 4px rgba(0,0,0,0.3);border:1px solid var(--border);}
  /* Abwechselndes Hintergrundmuster f√ºr bessere Lesbarkeit */
  .range-seg:nth-child(odd){background:var(--panel);}
  .range-seg:nth-child(even){background:var(--muted);}
  .range-seg .seg-label{font-weight:bold;display:block}
  .range-seg .seg-details{font-size:10px;color:#9ca3af;display:block}
</style>
</head>
<body>
<div class="box">

  <!-- üóÇÔ∏è Archiv -->
  <div class="panel" id="p-archiv" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üóÇÔ∏è</span><h2 style="margin:0">Archiv laden</h2><span class="pill">ZIP wird lokal entpackt</span></div>
    <p class="hint">
      Offizielles Archiv (manuell laden &amp; hier ausw√§hlen):
      <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a>
    </p>
    <div class="row">
      <div>
        <label>CSV/TXT oder ZIP ausw√§hlen</label>
        <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
        <div class="hint">Erkannt: ‚ÄûZahl1..Zahl20‚Äú, Spalte ‚Äû1-4-‚Ä¶‚Äú oder freie Zahlzeilen.</div>
      </div>
      <div>
        <label>Archiv-Status</label>
        <div id="statusTop" class="status">Bereit. (Kein Archiv geladen)</div>
        <div class="row" style="margin-top:6px"><button id="clearCache" class="danger">Archiv l√∂schen</button></div>
      </div>
    </div>
    <div class="row" style="margin-top:6px">
      <button id="autoLoad" class="secondary">‚¨áÔ∏è Offizielles Archiv automatisch laden</button>
      <label class="pill" style="display:flex;align-items:center;gap:6px">
        <input type="checkbox" id="autoloadOnStart"> beim Start laden
      </label>
    </div>
    <div class="row" style="margin-top:6px">
      <div style="flex:2 1 180px"><label>Download-Fortschritt</label><progress id="dlProg" value="0" max="1" style="display:none"></progress></div>
    </div>

    <!-- Alternative URL und Proxy-Optionen f√ºr Auto-Download -->
    <div class="row" style="margin-top:6px">
      <div style="flex:2 1 180px">
        <label>Alternative URL (optional)</label>
        <input type="text" id="customUrl" placeholder="https://example.com/archive.zip">
      </div>
      <div style="flex:1 1 180px">
        <label>Proxy (optional)</label>
        <input type="text" id="customProxy" placeholder="https://corsproxy.io/?">
      </div>
    </div>
  </div>

  <!-- üéõÔ∏è Einstellungen -->
  <div class="panel" id="p-settings" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üéõÔ∏è</span><h2 style="margin:0">Einstellungen</h2></div>
    <div class="row">
      <div>
        <label>Kombi-Gr√∂√üe (KENO-Typ)</label>
        <select id="kenoType">
          <option value="2">Typ 2</option><option value="3">Typ 3</option><option value="4">Typ 4</option>
          <option value="5">Typ 5</option><option value="6" selected>Typ 6</option><option value="7">Typ 7</option>
          <option value="8">Typ 8</option><option value="9">Typ 9</option><option value="10">Typ 10</option>
        </select>
      </div>
      <div><label>Max. erlaubte √úberschneidung</label><input type="number" id="maxOv" value="5" min="0" max="20"></div>
      <div><label>Zahlenbereich ‚Äì Von</label><input type="number" id="rangeFrom" value="1" min="1" max="200"></div>
      <div><label>Zahlenbereich ‚Äì Bis</label><input type="number" id="rangeTo" value="70" min="1" max="200"></div>
    </div>
  </div>

  <!-- üß© Muster -->
  <div class="panel" id="p-pattern" style="border-left:6px solid var(--warm)">
    <div class="ph" style="display:flex;align-items:center;gap:10px">
      <span class="emoji">üß©</span><h2 style="margin:0">Muster-Abst√§nde</h2><span class="pill">S = Abst√§nde + 1</span>
      <!-- Der Muster-Editor wird nur √ºber den ‚ÄûMuster verwenden‚Äú-Schalter gesteuert. -->
    </div>
    <label><input type="checkbox" id="usePattern"> Muster verwenden</label>
    <!-- Der Muster-Editor wird dynamisch durch den ‚ÄûMuster verwenden‚Äú-Schalter sichtbar oder ausgeblendet -->
    <div id="patternBox" style="display:none">
      <label>Aktuelles Muster (read-only)</label>
      <div id="gapLine" class="mono" style="margin:4px 0 8px;opacity:.9">[ ]</div>
      <div class="chips" id="chips"></div>
      <div class="hint">Ergebnis: <span id="sOut" class="badge">S = 1 Zahl</span></div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0">
        <button id="gapAdd" class="secondary">Ôºã Abstand</button>
        <button id="gapRemove" class="danger">Ôºç Abstand</button>
        <button id="gapClear" class="danger">‚úñÔ∏è Alles l√∂schen</button>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0">
        <button id="gapRand" class="secondary">üé≤ Zuf√§llig f√ºllen</button>
        <button id="gapAllPlus" class="secondary">‚§¥Ô∏é Alle +1</button>
        <button id="gapAllMinus" class="secondary">‚§µÔ∏é Alle ‚àí1</button>
        <button id="gapShuffle" class="ghost">üîÄ Mischen</button>
        <button id="gapReverse" class="ghost">‚ÜîÔ∏é Spiegeln</button>
      </div>
      <div class="panel" style="margin:10px 0 0">
        <div class="ph"><span class="emoji">üß™</span><h3 style="margin:0">√Ñhnliche Varianten</h3><span class="pill">3 Vorschl√§ge</span></div>
        <div class="row">
          <div><label>Vorschl√§ge</label><input type="number" id="varCount" value="3" min="1" max="50"></div>
          <div><label>√Ñhnlichkeit</label>
            <select id="simLevel"><option value="high">Hoch</option><option value="med" selected>Mittel</option><option value="low">Niedrig</option></select>
          </div>
        </div>
        <div class="row" style="margin-top:6px">
          <button id="makeVariants" class="secondary">Vorschl√§ge erzeugen</button>
          <button id="clearVariants" class="danger">Vorschl√§ge l√∂schen</button>
        </div>
        <div id="variantList" class="grid"></div>
      </div>
    </div>
  </div>

  <!-- üî• H√§ufige Gruppen -->
  <div class="panel" id="p-hot" style="border-left:6px solid #f472b6">
    <div class="ph"><span class="emoji">üî•</span><h2 style="margin:0">H√§ufige Gruppen</h2></div>
    <label style="display:flex;align-items:center;gap:8px">
      <input type="checkbox" id="useHotGroups"> <span>aktivieren</span>
    </label>
    <div id="hotBox" style="display:none">
      <div class="row">
        <div>
          <label>R√ºckblick Ziehungen</label>
          <!-- Anzeige der Anzahl der Ziehungen im Archiv. Wird nach dem Laden aktualisiert. -->
          <div id="hotWindowDisplay" class="status" style="padding:4px;min-width:80px;">0</div>
        </div>
        <div><label>Gruppengr√∂√üe</label>
          <select id="hotK">
            <option value="2" selected>2 (Paare)</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
        </div>
        <div><label>Top N</label><input type="number" id="hotTopN" value="30" min="5" max="1000"></div>
        <div><label>Modus</label>
          <select id="hotMode"><option value="require" selected>M√ºssen enthalten</option><option value="prefer">Bevorzugen</option></select>
        </div>
        <div style="display:none">
          <label>Suche-Stufe</label>
          <select id="searchLevel" style="display:none">
            <option value="normal" selected>Normal</option>
            <option value="medium">Mittel</option>
            <option value="hard">Hard</option>
          </select>
          <div id="hotHardWrap" class="hint" style="display:none;margin-top:6px">
            Hard-Zeit: 
            <select id="hotHardBudget" style="display:none">
              <option value="2">‚âà 2 min</option>
              <option value="5" selected>‚âà 5 min</option>
              <option value="10">‚âà 10 min</option>
              <option value="15">‚âà 15 min</option>
              <option value="30">‚âà 30 min</option>
              <option value="max">Maximum (ganze Historie)</option>
            </select>
          </div>
        </div>
      </div>
      <div class="row">
        <div style="flex:2 1 180px"><label>Info</label><div id="hotInfo" class="status">inaktiv</div></div>
        <div style="flex:1 1 180px"><label>Fortschritt</label><progress id="hotProg" value="0" max="1" style="display:none"></progress></div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="hotStart" class="secondary">Neu berechnen</button>
        <button id="hotCancel" class="danger" disabled>Abbrechen</button>
      </div>
    </div>
  </div>

  <!-- üßÆ Generieren -->
  <div class="panel" id="p-gen" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üßÆ</span><h2 style="margin:0">Kombinationen generieren</h2></div>
    <div class="row">
      <div><label>Wieviele Ergebnisse</label><input type="number" id="want" value="10" min="1" max="2000"></div>
      <div>
        <label>Seed
          <span class="hint" style="display:block;font-weight:normal">Startwert des Zufallszahlengenerators ‚Äì gleiche Seeds liefern identische Ergebnisse (√§hnlich wie bei echten KENO-Ziehungen). Sie k√∂nnen jetzt auch sehr lange Zahlen verwenden.</span>
        </label>
        <div style="display:flex;gap:6px;flex-wrap:wrap;align-items:flex-end">
          <!-- Den Seed als Textfeld definieren, damit auch sehr lange Zufallszahlen eingegeben werden k√∂nnen. Das pattern sorgt daf√ºr, dass nur Ziffern akzeptiert werden. -->
          <input type="text" id="seed" value="1" pattern="\d*" inputmode="numeric" style="flex:1 1 auto">
          <button id="seedRand" class="secondary" type="button">üé≤ Zufallsseed</button>
        </div>
      </div>
      <div>
        <label>Zeitlimit</label>
        <select id="genTime">
          <option value="2">‚âà 2&nbsp;min</option>
          <option value="5" selected>‚âà 5&nbsp;min</option>
          <option value="10">‚âà 10&nbsp;min</option>
          <option value="15">‚âà 15&nbsp;min</option>
          <option value="30">‚âà 30&nbsp;min</option>
          <option value="max">Maximales Limit</option>
        </select>
        <div class="hint">Nur relevant bei Zufall/Frequenz</div>
      </div>
    </div>
    <!-- Optionale mathematische Formel f√ºr die Seed-Erzeugung -->
    <div class="row" style="margin-top:6px">
      <div>
        <label>Seed-Formel</label>
        <select id="seedFormula">
          <option value="crypto" selected>Krypto-Zufall</option>
          <option value="fib">Fibonacci</option>
          <option value="prime">Primzahl</option>
        </select>
        <div class="hint">Mathematische Basis f√ºr den automatisch erzeugten Seed</div>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="go" class="primary">Generieren</button>
      <button id="save" class="secondary">Als CSV speichern</button>
      <button id="copyCombos" class="ghost">üìã Ergebnisse kopieren</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div style="flex:2 1 180px"><label>Generieren-Status</label><div id="genInfo" class="status">bereit</div></div>
      <div style="flex:1 1 180px"><label>Fortschritt</label><progress id="genProg" value="0" max="1" style="display:none"></progress></div>
    </div>
    <div class="row" style="margin-top:6px"><button id="genCancel" class="danger" disabled>Generieren abbrechen</button></div>

    <div class="row" style="margin-top:6px">
      <div>
        <label>Generator-Modus</label>
        <select id="genMode">
          <option value="random" selected>Zufall (kein Muster)</option>
          <option value="freq">Frequenz-basiert (h√§ufige Zahlen bevorzugen)</option>
          <!-- Neue intelligente Modi f√ºr KENO Typ 10 -->
          <option value="smart10">Intelligent (Typ 10)</option>
          <option value="smart10-hot">Intelligent (Typ 10 ¬∑ Hot)</option>
          <option value="smart10-cold">Intelligent (Typ 10 ¬∑ Cold)</option>
          <option value="smart10-mix">Intelligent (Typ 10 ¬∑ Mix)</option>
          <option value="smart10-cover">Intelligent (Typ 10 ¬∑ Abdeckung)</option>
          <!-- ‚ÄûHot-Paare‚Äú wurde entfernt; diese Funktion ist √ºber die Hot-Gruppen separat erreichbar -->
        </select>
        <div class="hint">Gilt nur, wenn <b>kein Muster</b> genutzt wird.</div>
      </div>
      <div id="hotPairsBox" style="display:none">
        <label>Hot-Paare Einstellungen</label>
        <div class="row">
          <!-- Fenster-Anzeige ersetzt das Eingabefeld. Es zeigt die Archivgr√∂√üe an und ist nicht editierbar. -->
          <div><label>Fenster (Ziehungen)</label><div id="hpWindowDisplay" class="status" style="padding:4px;min-width:80px">0</div></div>
          <div><label>Top-N Paare</label><input type="number" id="hpTopN" value="50" min="5" max="2000"></div>
          <div><label>Mind. Paar-Treffer</label><input type="number" id="hpMinPairs" value="1" min="0" max="5"></div>
          <div><label>Gewichtung</label>
            <select id="hpWeight">
              <option value="soft" selected>Weich (bevorzugen)</option>
              <option value="hard">Hart (erzwingen)</option>
            </select>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- üó∫Ô∏è Bereichs-Regeln -->
  <div class="panel" id="p-range-rules" style="border-left:6px solid #94a3b8">
    <div class="ph"><span class="emoji">üó∫Ô∏è</span><h3 style="margin:0">Bereichs-Regeln</h3><span class="pill">jede Teil-Range</span></div>
    <label style="display:flex;align-items:center;gap:8px">
      <input type="checkbox" id="useRangeRules"> <span>aktivieren</span>
    </label>
    <div id="rangeRulesBox" style="display:none">
      <div class="row">
        <div><label>Segment-L√§nge (Anzahl Zahlen)</label><input type="number" id="segSize" value="10" min="2" max="50"></div>
        <div><label>Min pro Segment</label><input type="number" id="segMin" value="0" min="0" max="10"></div>
        <div><label>Max pro Segment</label><input type="number" id="segMax" value="10" min="1" max="20"></div>
      </div>
      <div class="hint">Beispiel: Bei A = 1, B = 70 und Segment-L√§nge 10 ergeben sich die Segmente 1‚Äì10, 11‚Äì20, ‚Ä¶, 61‚Äì70.</div>
      <!-- Dynamisch generierte Zusammenfassung der Bereichsregel -->
      <div id="rangeSummary" class="hint" style="margin-top:4px"></div>
      <div id="rangeMap" class="range-map"></div>
    </div>
  </div>

  <!-- üìä Statistik -->
  <div class="panel" id="p-stats" style="border-left:6px solid var(--accent2)">
    <div class="ph"><span class="emoji">üìä</span><h2 style="margin:0">Statistik</h2></div>
    <div class="row">
      <div>
        <button id="calcStats" class="secondary">Statistik berechnen</button>
      </div>
      <div>
        <label>Ziehungsfenster</label>
        <select id="statsWindow">
          <option value="all" selected>Alle</option>
          <option value="15">Letzte&nbsp;15</option>
          <option value="50">Letzte&nbsp;50</option>
          <option value="100">Letzte&nbsp;100</option>
        </select>
        <div class="hint">Fenstergr√∂√üe der letzten Ziehungen</div>
      </div>
    </div>
    <div id="statsInfo" class="status" style="display:none;margin-top:6px"></div>
    <!-- Statt einer Balkengrafik wird hier eine Top-Liste angezeigt -->
    <div id="statsList" class="status" style="display:none;margin-top:6px"></div>
  </div>


  <!-- ü§ñ Agent-Modus entfernt -->

  <!-- üß† Tipp pr√ºfen -->
  <div class="panel" id="p-analyse" style="border-left:6px solid var(--accent)">
    <div class="ph"><span class="emoji">üß†</span><h2 style="margin:0">Tipp analysieren</h2><span class="pill">Auto-Scroll hierher</span></div>
    <div style="margin:4px 0">
      <input type="checkbox" id="autoThr" checked>
      <label for="autoThr">Schwellen automatisch an KENO-Typ koppeln</label>
    </div>
    <label>Dein Tipp (Zahlen mit Leerzeichen/Komma)</label>
    <input type="text" id="tipInput" placeholder="z. B. 10 11 16 22 24 44 48 49 50 52">
    <div class="row" style="margin-top:6px">
      <div><label>√úberschneidung z√§hlen ab (‚â•)</label><input type="number" id="thrA" value="5" min="1" max="20"></div>
      <div><label>2. Schwelle (optional, ‚â•)</label><input type="number" id="thrB" value="6" min="1" max="20"></div>
    </div>
    <div style="margin-top:6px" class="row">
      <button id="checkTip" class="secondary">Tipp analysieren</button>
      <button id="saveTipFav" class="ghost">‚≠êÔ∏é Tipp speichern (mit Notiz)</button>
    </div>
    <div id="tipStatus" class="status" style="display:none"></div>
  </div>

  <!-- ‚≠ê Favoriten -->
  <div class="panel" id="p-favs" style="border-left:6px solid var(--warm)">
    <div class="ph"><span class="emoji">‚≠ê</span><h2 style="margin:0">Favoriten &amp; Notizen</h2>
      <button id="favToggle" class="ghost" style="margin-left:auto">üëÅÔ∏è Favoriten ein-/ausblenden</button>
    </div>
    <div class="row">
      <div>
        <label>Aktionen</label>
        <div class="row">
          <button id="favExport" class="secondary">Exportieren (JSON)</button>
          <input type="file" id="favImportFile" accept="application/json">
          <button id="favClear" class="danger">Alle Favoriten l√∂schen</button>
        </div>
      </div>
    </div>
    <div id="favList" class="grid" style="margin-top:8px"></div>
  </div>

  <!-- üìã Ergebnisse -->
  <div class="panel" id="p-results">
    <div class="ph"><span class="emoji">üìã</span><h2 style="margin:0">Ergebnisse</h2></div>
    <div id="results" class="results"></div>
    <div id="resultStatus" class="status" style="display:none;margin-top:10px"></div>
  </div>

</div>

<!-- JSZip (ZIP-Entpacken im Browser) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(function(){
  "use strict";
  const $=s=>document.querySelector(s);
  const text=(el,s)=>{ if(el) el.textContent=s; };
  const html=(el,s)=>{ if(el) el.innerHTML=s; };
  const uniqSorted=a=>Array.from(new Set(a)).sort((x,y)=>x-y);
  const sum=a=>a.reduce((s,x)=>s+x,0);
  const scrollToNode=n=>{ if(!n) return; n.scrollIntoView({behavior:"smooth", block:"start"}); };

  const CACHE_KEY="keno_archive_v3";
  const PATTERN_KEY="keno_pattern_v1";
  const USEPAT_KEY="keno_usepat_v1";
  const FAV_KEY="keno_favorites_v1";
  const FAV_VISIBLE_KEY="keno_fav_visible_v1";
  const OFFICIAL_ZIP_URL = "https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip";

  // Eingebettetes Beispielarchiv (als Fallback bei fehlendem Netzwerk). 50 Zeilen mit jeweils 10 Zahlen
  const SAMPLE_ARCHIVE_RAW = `6 34 50 51 52 54 59 63 66 69
7 9 18 28 37 39 46 49 62 65
7 10 13 19 31 33 36 40 43 69
4 27 34 41 46 52 56 57 59 62
1 2 12 21 32 43 46 47 52 64
6 9 12 19 21 25 29 31 57 58
14 16 35 38 39 43 53 60 63 66
12 13 19 27 31 37 41 50 57 67
5 9 10 12 17 24 34 57 60 61
5 11 18 28 29 31 36 38 51 54
11 13 15 16 42 43 46 55 63 64
3 4 15 22 28 29 35 43 48 53
4 6 10 13 16 19 29 39 41 70
3 5 12 13 15 16 48 51 62 68
3 5 8 13 16 17 27 54 55 62
3 8 10 24 29 30 33 39 45 56
13 14 22 26 34 44 45 46 51 61
1 8 12 16 21 33 43 44 57 69
10 33 36 40 45 46 50 53 61 66
2 6 11 16 18 31 36 43 49 59
6 17 37 40 42 46 50 54 64 70
1 21 25 29 31 43 46 57 58 69
5 6 17 22 45 52 54 58 69 70
1 5 20 21 54 58 63 64 68 70
2 7 11 17 25 26 44 54 60 61
1 2 8 13 28 39 41 54 64 68
2 6 13 24 26 36 39 41 51 61
10 15 18 33 36 45 56 58 66 68
3 6 27 34 37 41 47 59 61 69
6 19 23 25 27 38 48 56 59 64
2 6 18 20 22 35 43 44 46 48
5 6 9 20 21 26 35 36 38 47
7 15 23 31 34 38 40 47 55 62
7 10 14 36 39 43 52 54 59 69
15 16 28 32 44 45 61 62 68 70
5 6 12 20 22 39 43 49 52 70
2 8 13 19 26 29 34 36 50 51
11 17 28 29 38 48 50 55 58 63
4 9 15 22 25 29 34 46 56 58
6 14 16 26 27 33 51 52 61 64
7 14 19 20 26 32 39 47 49 59
19 32 41 42 43 52 55 64 66 67
2 5 10 26 29 34 41 42 44 56
9 11 20 33 34 38 49 56 59 61
2 6 9 17 29 39 49 55 68 70
20 21 33 34 43 48 49 58 59 65
5 10 12 27 35 38 39 55 58 67
1 3 20 24 30 33 37 50 54 62
9 25 33 34 39 43 52 53 63 64
3 8 17 21 31 37 43 61 67 70`;
  const ARCHIVE_META_KEY = "keno_archive_meta_v1";
    let g_draws=[], g_drawSize=0, g_pattern=[];
  let g_hotGroups=[], g_hotMeta={k:2,window:500,topN:30,mode:"require",level:"normal"};
  let hotWorker=null, genWorker=null;

  /* ===================== Archiv laden (CSV/TXT/ZIP) ===================== */
  function splitSmart(line){
    if(/\t/.test(line)) return line.split("\t");
    if(line.includes(";")) return line.split(";");
    if(line.includes("|")) return line.split("|");
    if(/,/.test(line) && !/^\d+(?:-\d+)+$/.test(line.trim())) return line.split(",");
    return line.trim().split(/\s+/);
  }
  function parseTable(text){return text.split(/\r?\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart);}  
  function tryZahlHeader(rows){
    if(!rows.length) return null;
    const header=rows[0], idx=[];
    for(let i=0;i<header.length;i++) if(/^zahl\s*\d+$/i.test(String(header[i]).trim())) idx.push(i);
    if(idx.length>=5){
      const lists=[]; for(let r=1;r<rows.length;r++){
        const nums=idx.map(i=>parseInt(String(rows[r][i]||"").trim(),10)).filter(Number.isInteger);
        if(nums.length) lists.push(nums);
      }
      return {lists, info:`Header erkannt (${idx.length} Zahl-Spalten)`};
    }
    return null;
  }
  function detectDashCol(rows){
    let maxCols=0; for(const r of rows) if(r.length>maxCols) maxCols=r.length;
    let best=-1,score=-1;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        if(c>=r.length) continue;
        const cell=String(r[c]||"").trim(); if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\d+$/.test(p.trim()))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }
  function fallbackExtract(raw){
    const out=[];
    for(const lnRaw of raw.split(/\r?\n/)){
      const ln=lnRaw.trim(); if(!ln) continue;
      if(/^\d+(?:-\d+)+$/.test(ln)){ out.push(ln.split("-").map(n=>parseInt(n,10)).filter(Number.isInteger)); continue; }
      const nums=(ln.match(/\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
      if(nums.length>=5) out.push(nums);
    }
    return out;
  }
  function loadArchiveFromRawText(raw, sourceLabel){
    const rows=parseTable(raw);
    let lists=[], detected="", z, ncol;

    z=tryZahlHeader(rows);
    if(z){ lists=z.lists; detected=z.info; }
    else{
      ncol=detectDashCol(rows);
      if(ncol>=0){
        for(const r of rows){
          if(ncol>=r.length) continue;
          const cell=String(r[ncol]||"").trim(); if(!cell) continue;
          const parts=cell.split("-");
          if(parts.length && parts.every(p=>/^\d+$/.test(p.trim()))) lists.push(parts.map(x=>parseInt(x,10)));
        }
        detected="Spalte 1-4-‚Ä¶";
      }else{
        lists=fallbackExtract(raw);
        detected="Fallback: freie Zahlzeilen";
      }
    }
    if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");
    const freq=new Map(); for(const a of lists){ if(a.length>=5 && a.length<=20) freq.set(a.length,(freq.get(a.length)||0)+1); }
    let bestLen=0, bestCnt=-1; for(const [k,v] of freq.entries()){ if(v>bestCnt){ bestCnt=v; bestLen=k; } }
    if(!bestLen) throw new Error("Keine Listen der L√§nge 5‚Äì20 erkannt.");
    g_drawSize=bestLen;

    g_draws = lists.filter(a=>a.length===g_drawSize).map(arr => uniqSorted(arr.filter(n=>Number.isInteger(n))));
    if(!g_draws.length) throw new Error("Nach Filter auf dominierende L√§nge keine Ziehungen √ºbrig.");

    try{ localStorage.setItem(CACHE_KEY, JSON.stringify({draws:g_draws, drawSize:g_drawSize, savedAt:Date.now(), source:sourceLabel||""})); }catch{}
    text($("#statusTop"), `Archiv geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ ${detected}${sourceLabel?` ¬∑ Quelle: ${sourceLabel}`:""}`);
    // Aktualisiere die Anzeige f√ºr R√ºckblick-Ziehungen (Hot-Gruppen) und Hot-Paare
    const hotDisplay = document.getElementById('hotWindowDisplay');
    if(hotDisplay) hotDisplay.textContent = g_draws.length.toString();
    const hpDisp = document.getElementById('hpWindowDisplay');
    if(hpDisp) hpDisp.textContent = g_draws.length.toString();
  }
  async function handleAnyFile(file){
    if(!file) return;
    text($("#statusTop"), `Lese Datei: ${file.name}`);
    const name=file.name.toLowerCase();
    try{
      if(name.endsWith(".zip")){
        if(!window.JSZip){ alert("JSZip fehlt (CDN)"); return; }
        const ab = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(ab);
        const candidates=[];
        zip.forEach((path, entry)=>{
          const p=path.toLowerCase();
          if(p.endsWith(".csv") || p.endsWith(".txt")){
            const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
            candidates.push({path,entry,score,size:entry._dataUncompressedSize||0});
          }
        });
        if(!candidates.length) throw new Error("Keine CSV/TXT im ZIP gefunden");
        candidates.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
        const target=candidates[0];
        text($("#statusTop"), `Entpacke & lese: ${target.path}`);
        let raw="";
        try{ raw = await target.entry.async("string"); }
        catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
        loadArchiveFromRawText(raw, `ZIP: ${target.path}`);
      }else{
        const txt = await file.text();
        loadArchiveFromRawText(txt, file.name||"Upload");
      }
      if($("#useHotGroups").checked) recomputeHotGroups();
    }catch(e){
      text($("#statusTop"), "Fehler beim Lesen: "+(e?.message||e));
      g_draws=[]; g_drawSize=0;
    }
  }
  $("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
  $("#clearCache").addEventListener("click",()=>{
    try{ localStorage.removeItem(CACHE_KEY); }catch{}
    g_draws=[]; g_drawSize=0;
    text($("#statusTop"), "Archiv gel√∂scht. Bitte Datei erneut laden.");
    $("#results").innerHTML=""; $("#resultStatus").style.display="none";
    // Aktualisiere Hot-Gruppen- und Hot-Paare-Anzeigen nach dem L√∂schen
    const hotDisplayDel = document.getElementById('hotWindowDisplay');
    if(hotDisplayDel) hotDisplayDel.textContent = '0';
    const hpDispDel = document.getElementById('hpWindowDisplay');
    if(hpDispDel) hpDispDel.textContent = '0';
  });

  // Fetch with progress for auto-load
  async function fetchWithProgress(url, onProgress){
    const res = await fetch(url, { cache:"no-cache" });
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const total = +(res.headers.get("Content-Length")||0);
    const reader = res.body?.getReader?.();
    if(!reader) return { arrayBuffer: await res.arrayBuffer(), total };
    let received = 0;
    const chunks = [];
    while(true){
      const {done, value} = await reader.read();
      if(done) break;
      chunks.push(value);
      received += value.length;
      if(typeof onProgress === "function"){
        onProgress({ received, total });
      }
    }
    const blob = new Blob(chunks);
    return { arrayBuffer: await blob.arrayBuffer(), total: total||received, res };
  }

  // Versuche, eine der gegebenen URLs herunterzuladen. Es wird der erste erfolgreiche Versuch zur√ºckgegeben.
  async function attemptDownload(urls, onProgress){
    let lastError = null;
    for(const url of urls){
      try{
        const result = await fetchWithProgress(url, onProgress);
        result.usedUrl = url;
        return result;
      }catch(e){ lastError = e; }
    }
    throw lastError || new Error('Download fehlgeschlagen');
  }
  async function autoLoadOfficialArchive(){
    const prog = $("#dlProg");
    const st = $("#statusTop");
    $("#dlProg").style.display="";
    $("#dlProg").value=0; $("#dlProg").max=1;
    text(st, "Verbinde zur Quelle‚Ä¶");
    try{
      // Ermittle Basis-URL und Proxy
      const custom = $("#customUrl").value.trim();
      const baseUrl = custom || OFFICIAL_ZIP_URL;
      const proxy = $("#customProxy").value.trim();
      // Liste m√∂glicher Download-URLs: benutzerdefinierter Proxy, Original, √∂ffentliche CORS-Proxies
      const candidates = [];
      if(proxy){ candidates.push(proxy + baseUrl); }
      // direkte URL zuletzt, damit Proxy bevorzugt wird
      candidates.push(baseUrl);
      // bekannte kostenlose Proxies (encode URI bei bedarf)
      candidates.push('https://corsproxy.io/?' + encodeURIComponent(baseUrl));
      candidates.push('https://api.allorigins.win/raw?url=' + encodeURIComponent(baseUrl));
      candidates.push('https://thingproxy.freeboard.io/fetch/' + baseUrl);
      // Fortschrittsanzeige (wird jedes Mal aktualisiert)
      const { arrayBuffer, res, usedUrl } = await attemptDownload(candidates, ({received, total})=>{
        if(total>0) { prog.value = received/total; text(st, `Lade Archiv‚Ä¶ ${(100*received/total).toFixed(0)}%`); }
        else { prog.value = Math.min(1, prog.value + 0.02); text(st, `Lade Archiv‚Ä¶ ${received.toLocaleString()} Bytes`); }
      });
      // Speichere ETag/Last-Modified f√ºr Info
      const meta = {
        etag: res?.headers?.get?.("ETag") || null,
        lm: res?.headers?.get?.("Last-Modified") || null,
        savedAt: Date.now(),
        used: usedUrl
      };
      try{ localStorage.setItem(ARCHIVE_META_KEY, JSON.stringify(meta)); }catch{}
      text(st, "Entpacke ZIP‚Ä¶");
      if(!window.JSZip) throw new Error("JSZip fehlt (CDN)");
      const zip = await JSZip.loadAsync(arrayBuffer);
      const candidates2=[];
      zip.forEach((path, entry)=>{
        const p=path.toLowerCase();
        if(p.endsWith(".csv") || p.endsWith(".txt")){
          const score=(/\bkeno\b/.test(p)?3:0)+(/\barchiv\b/.test(p)?2:0)+(p.endsWith(".csv")?1:0);
          candidates2.push({path,entry,score,size:entry._dataUncompressedSize||0});
        }
      });
      if(!candidates2.length) throw new Error("Keine CSV/TXT im ZIP gefunden (Quelle ge√§ndert?)");
      candidates2.sort((a,b)=> b.score-b.score || b.size-b.size || (a.path<b.path?-1:1));
      const target=candidates2[0];
      text(st, `Lese: ${target.path}`);
      let raw="";
      try{ raw = await target.entry.async("string"); }
      catch(_){ const u8=new Uint8Array(await target.entry.async("uint8array")); raw=new TextDecoder("utf-8",{fatal:false}).decode(u8); }
      loadArchiveFromRawText(raw, `Auto: ${target.path}`);
      $("#dlProg").style.display="none";
      if($("#useHotGroups").checked) recomputeHotGroups();
    }catch(e){
      // Download fehlgeschlagen: Verstecke Fortschritt und lade eingebettetes Beispiel
      $("#dlProg").style.display="none";
      const hint = (String(e?.message||e).includes("TypeError")||String(e?.message||e).includes("Failed to fetch"))
        ? " (Hinweis: CORS-Fehler: Versuche einen Proxy oder lade manuell)"
        : "";
      text($("#statusTop"), "Auto-Laden fehlgeschlagen: "+(e?.message||e)+hint+". Verwende Beispiel-Daten ‚Ä¶");
      try{
        loadArchiveFromRawText(SAMPLE_ARCHIVE_RAW, 'Beispiel');
        // Anzeige aktualisieren
        $("#dlProg").style.display = 'none';
        if($("#useHotGroups").checked) recomputeHotGroups();
        // R√ºckblick-Anzeige aktualisieren
        const hwd = document.getElementById('hotWindowDisplay'); if(hwd) hwd.textContent = g_draws.length.toString();
        const hpd = document.getElementById('hpWindowDisplay'); if(hpd) hpd.textContent = g_draws.length.toString();
      }catch(err){
        console.error(err);
      }
    }
  }

  // Drag & Drop aufs Archiv-Panel
  const archPanel = document.getElementById("p-archiv");
  ["dragenter","dragover"].forEach(ev=> archPanel.addEventListener(ev, e=>{ e.preventDefault(); e.dataTransfer.dropEffect="copy"; }));
  archPanel.addEventListener("drop", e=>{
    e.preventDefault();
    const f = e.dataTransfer.files?.[0];
    if(f) handleAnyFile(f);
  });

  /* ===================== Init ===================== */
  (function(){
    try{
      const raw=localStorage.getItem(CACHE_KEY);
      if(raw){
        const obj=JSON.parse(raw)||{}; g_draws=obj.draws||[]; g_drawSize=obj.drawSize||0;
        if(g_draws.length){
          const ts=obj.savedAt?new Date(obj.savedAt):new Date();
          const src=obj.source?` ¬∑ Quelle: ${obj.source}`:"";
          text($("#statusTop"), `Archiv aus Browser geladen: ${g_draws.length} Ziehungen (Ziehungsgr√∂√üe ${g_drawSize}) ¬∑ gespeichert am ${ts.toLocaleDateString()} ${ts.toLocaleTimeString()}${src}`);
          // Anzeige f√ºr R√ºckblick-Ziehungen aktualisieren
          const hotDisplayInit = document.getElementById('hotWindowDisplay');
          if(hotDisplayInit) hotDisplayInit.textContent = g_draws.length.toString();
          const hpDispInit = document.getElementById('hpWindowDisplay');
          if(hpDispInit) hpDispInit.textContent = g_draws.length.toString();
        }
      }
    }catch{}
    try{ const p=localStorage.getItem(PATTERN_KEY); g_pattern=p?JSON.parse(p):[]; }catch{ g_pattern=[]; }
    renderPattern();
    const usePat=(localStorage.getItem(USEPAT_KEY)==="1"); $("#usePattern").checked=!!usePat; togglePatternBox();
    syncToKenoType(true);
    renderFavorites();
    const favVis = localStorage.getItem(FAV_VISIBLE_KEY);
    if(favVis==="0") $("#favList").style.display="none";
    toggleHardUIs();
    // Suchstufe und Zeitbudget f√ºr Hot-Gruppen fixieren auf ‚ÄûHard‚Äú / ‚ÄûMaximum‚Äú
    const slEl = document.getElementById('searchLevel');
    if(slEl){ slEl.value = 'hard'; }
    const hbEl = document.getElementById('hotHardBudget');
    if(hbEl){ hbEl.value = 'max'; }
    const hwEl = document.getElementById('hotHardWrap');
    if(hwEl){ hwEl.style.display = 'none'; }
    // Autoload settings
    try{
      const autoload = localStorage.getItem("keno_autoload_onstart")==="1";
      $("#autoloadOnStart").checked = autoload;
      if(autoload){
        const haveCache = !!(g_draws && g_draws.length);
        if(!haveCache){
          // Versuche automatisch zu laden (wenn noch nichts im Cache liegt)
          setTimeout(()=>{ $("#autoLoad").disabled=true; autoLoadOfficialArchive().finally(()=>$("#autoLoad").disabled=false); }, 300);
        }
      }
    }catch{}
  })();

  /* ===================== KENO-Typ & Muster ===================== */
  function getS(){ let s=parseInt($("#kenoType").value,10); if(isNaN(s)||s<2||s>10) s=6; return s; }
  function syncToKenoType(onInit){
    const Sval=getS();
    $("#maxOv").value = Math.max(0,Sval-1);
    if($("#autoThr").checked){ $("#thrA").value = Math.max(1,Sval-1); $("#thrB").value = Sval; }
    if(g_pattern.length!==Sval-1){
      if(g_pattern.length<Sval-1) g_pattern = g_pattern.concat(Array(Sval-1-g_pattern.length).fill(1));
      else g_pattern = g_pattern.slice(0,Sval-1);
      savePattern(); renderPattern();
    }
    if(!onInit) text($("#statusTop"), `KENO-Typ ${Sval} aktiv ¬∑ maxOv=${Sval-1} ¬∑ Schwellen ${Sval-1}/${Sval}`);
  }
  $("#kenoType").addEventListener("change", ()=>syncToKenoType(false));
  $("#autoThr").addEventListener("change", ()=>syncToKenoType(false));

  function renderPattern(){
    const chips=$("#chips"); chips.innerHTML="";
    g_pattern.forEach((v,i)=>{
      const el=document.createElement("span");
      el.className="chip";
      el.innerHTML = `<button class="secondary" data-act="dec" data-idx="${i}">‚àí</button>
                      <span class="val">${v}</span>
                      <button class="secondary" data-act="inc" data-idx="${i}">Ôºã</button>`;
      chips.appendChild(el);
    });
    $("#gapLine").textContent = g_pattern.length ? "[ "+g_pattern.join(", ")+" ]" : "[ ]";
    $("#sOut").textContent = "S = "+(g_pattern.length+1)+" Zahlen";
  }
  function savePattern(){ try{ localStorage.setItem(PATTERN_KEY, JSON.stringify(g_pattern)); }catch{} }
  function togglePatternBox(){
    const on = $("#usePattern").checked;
    const box = $("#patternBox");
    if(!box) return;
    box.style.display = on ? "" : "none";
    try{ localStorage.setItem(USEPAT_KEY, on ? "1" : "0"); }catch{}
  }
  $("#usePattern").addEventListener("change", togglePatternBox);
  $("#chips").addEventListener("click", e=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const i=+btn.dataset.idx, act=btn.dataset.act;
    if(!(i>=0) || i>=g_pattern.length) return;
    if(act==="inc") g_pattern[i]+=1;
    else if(act==="dec") g_pattern[i]=Math.max(1,g_pattern[i]-1);
    savePattern(); renderPattern();
    text($("#statusTop"), `Muster: [${g_pattern.join(", ")}] ‚Üí S=${g_pattern.length+1}`);
  });
  $("#gapAdd").addEventListener("click", ()=>{ g_pattern.push(1); savePattern(); renderPattern(); text($("#statusTop"), "Abstand +1. S="+(g_pattern.length+1)); });
  $("#gapRemove").addEventListener("click", ()=>{ if(g_pattern.length){ g_pattern.pop(); savePattern(); renderPattern(); text($("#statusTop"), "Abstand entfernt. S="+(g_pattern.length+1)); }});
  $("#gapClear").addEventListener("click", ()=>{ g_pattern=[]; savePattern(); renderPattern(); });
  const shuffle=a=>a.map(v=>[v,Math.random()]).sort((x,y)=>x[1]-y[1]).map(x=>x[0]);
  const reverseArr=a=>a.slice().reverse();
  const maxGapGuess=k=>{ const A=+$("#rangeFrom").value, B=+$("#rangeTo").value; const span=Math.max(1,B-A); return Math.max(1, Math.floor(span/k)); };
  function setPattern(arr){ g_pattern=arr.map(x=>Math.max(1,x|0)); savePattern(); renderPattern(); $("#usePattern").checked=true; togglePatternBox(); }
  function randomFill(){ const Sval=getS(),k=Sval-1,mg=Math.max(1,maxGapGuess(k)); setPattern(Array.from({length:k},()=>1+Math.floor(Math.random()*mg))); }
  function incAll(d){ if(!g_pattern.length){ alert("Kein Muster ‚Äì zuerst anlegen."); return; } setPattern(g_pattern.map(x=>Math.max(1,x+d))); }
  $("#gapRand").addEventListener("click", randomFill);
  $("#gapAllPlus").addEventListener("click", ()=>incAll(+1));
  $("#gapAllMinus").addEventListener("click", ()=>incAll(-1));
  $("#gapShuffle").addEventListener("click", ()=>{ if(!g_pattern.length){ alert("Kein Muster ‚Äì zuerst anlegen."); return; } setPattern(shuffle(g_pattern)); });
  $("#gapReverse").addEventListener("click", ()=>{ if(!g_pattern.length){ alert("Kein Muster ‚Äì zuerst anlegen."); return; } setPattern(reverseArr(g_pattern)); });

  /* ===================== Varianten / Stats ===================== */
  function computeStats(A,B){
    const n=B-A+1, freq=Array(n).fill(0), last=Array(n).fill(-1);
    for(let d=0; d<g_draws.length; d++){
      for(const v of g_draws[d]){
        if(v<A||v>B) continue;
        const idx=v-A; freq[idx]++; last[idx]=d;
      }
    }
    const rec=last.map(x=> x<0 ? 9999 : (g_draws.length-1-x));
    return {freq,rec};
  }
  function scorePattern(gaps,A,B,stats){
    const price=Array.from({length:B-A+1},(_,i)=> (stats.freq[i]||0)*0.6 + (1/((stats.rec[i]||9999)+1))*0.8);
    const inc=sum(gaps),startMax=B-inc; if(startMax<A) return {score:Infinity,start:A};
    let best=Infinity,bestStart=A;
    for(let s=A;s<=startMax;s++){
      let cost=0,cur=s; cost+=price[cur-A];
      for(const g of gaps){ cur+=g; cost+=price[cur-A]; }
      if(cost<best){best=cost;bestStart=s;}
    }
    return {score:+best.toFixed(3),start:bestStart};
  }
  const similarity=(a,b)=>{ const k=a.length; let same=0; for(let i=0;i<k;i++) if(Math.abs(a[i]-b[i])<=1) same++; return same/k; };
  function mutateNear(base,level){
    const g=base.slice(),k=g.length; const ops = level==='high'? 1 : level==='med'? 2 : 3+Math.floor(Math.random()*2);
    for(let t=0;t<ops;t++){
      const r=Math.random(), i=Math.floor(Math.random()*k), j=Math.floor(Math.random()*k);
      if(r<0.33 && k>1 && i!==j){ const tmp=g[i]; g[i]=g[j]; g[j]=tmp; }
      else if(r<0.66 && i!==j && g[i]>1){ g[i]-=1; g[j]+=1; }
      else { if(Math.random()<0.5) g[i]+=1; else if(g[i]>1) g[i]-=1; }
    }
    for(let i=0;i<k;i++) if(g[i]<1) g[i]=1;
    return g;
  }
  function generateVariants(baseGaps,{A,B,count,simLevel}){
    const stats=computeStats(A,B), out=[], seen=new Set();
    const tol = simLevel==='high'? 0.9 : simLevel==='med'? 0.75 : 0.55;
    const divTol = 0.9; let tries=0, budget=count*25;
    while(out.length<count && tries<budget){
      tries++;
      const g=mutateNear(baseGaps,simLevel);
      const key=g.join(","); if(seen.has(key)) continue; seen.add(key);
      if(A+g.reduce((a,b)=>a+b,0)>B) continue;
      if(similarity(baseGaps,g) < tol) continue;
      if(out.some(v=> similarity(v.gaps,g)>divTol)) continue;
      const {score,start}=scorePattern(g,A,B,stats);
      out.push({gaps:g,score,start});
    }
    out.sort((x,y)=>x.score-y.score);
    return out.slice(0,count);
  }
  function renderVariantList(items){
    const box=$("#variantList"); box.innerHTML="";
    if(!items.length){ box.innerHTML='<div class="hint">(keine Vorschl√§ge ‚Äì √Ñhnlichkeit/Bereich anpassen)</div>'; return; }
    box._data = items.slice();
    for(const [idx,it] of items.entries()){
      const s=it.gaps.length+1;
      const div=document.createElement("div");
      div.className="favCard";
      div.innerHTML=`
        <span class="badge">#${idx+1}</span>
        <span class="mono">[ ${it.gaps.join(", ")} ]</span>
        <span class="badge">S=${s}</span>
        <span class="badge">Score=${it.score}</span>
        <span class="badge">Start=${it.start}</span>
        <div style="margin-top:6px;display:flex;gap:6px">
          <button class="secondary" data-act="use" data-idx="${idx}">√úbernehmen</button>
          <button class="danger" data-act="del" data-idx="${idx}">L√∂schen</button>
        </div>
      `;
      box.appendChild(div);
    }
  }
  $("#makeVariants").addEventListener("click", ()=>{
    if(!g_draws.length){ alert("Bitte zuerst Archiv laden."); return; }
    if(!g_pattern.length){ alert("Bitte zuerst Abst√§nde mit +/‚àí festlegen."); return; }
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const count=+$("#varCount").value, simLevel=$("#simLevel").value;
    const items=generateVariants(g_pattern.slice(),{A,B,count,simLevel});
    renderVariantList(items);
    text($("#statusTop"), items.length? `√Ñhnliche Vorschl√§ge: ${items.length} (√§hnlich=${simLevel}).`
                                   : "Keine passenden Vorschl√§ge ‚Äì √Ñhnlichkeit erh√∂hen oder Bereich anpassen.");
  });
  $("#clearVariants").addEventListener("click",()=>{ $("#variantList").innerHTML=""; $("#variantList")._data=[]; });
  $("#variantList").addEventListener("click",(e)=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const i=+btn.dataset.idx, act=btn.dataset.act, list=$("#variantList")._data||[];
    const it=list[i]; if(!it) return;
    if(act==="use"){ setPattern(it.gaps.slice()); text($("#statusTop"), `Muster √ºbernommen: [${g_pattern.join(", ")} ] (S=${g_pattern.length+1})`); }
    else if(act==="del"){ list.splice(i,1); renderVariantList(list); }
  });

  /* ===================== Hard-UIs sichtbar/unsichtbar ===================== */
  function toggleHardUIs(){
    $("#hotHardWrap").style.display = ($("#searchLevel").value==="hard") ? "" : "none";
    // Das Generator-Zeitlimit wird √ºber #genTime gew√§hlt; eine separate Hard-Wrap-UI ist nicht mehr erforderlich.
  }
  $("#searchLevel").addEventListener("change", ()=>{ toggleHardUIs(); if($("#useHotGroups").checked) recomputeHotGroups(); });
  $("#hotHardBudget").addEventListener("change", ()=>{ if($("#useHotGroups").checked) recomputeHotGroups(); });

  /* ===================== Hot-Gruppen (inkl. k=5 Maximum 2-Pass) ===================== */
  function toggleHotBox(){ const on=$("#useHotGroups").checked; $("#hotBox").style.display=on?"":"none"; text($("#hotInfo"), on?"bereit":"inaktiv"); }
  $("#useHotGroups").addEventListener("change", ()=>{ toggleHotBox(); if($("#useHotGroups").checked) recomputeHotGroups(); });
  ["hotK","hotTopN","hotMode"].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.addEventListener("change", ()=>{ if($("#useHotGroups").checked) recomputeHotGroups(); });
  });
  $("#hotStart").addEventListener("click", ()=>{ if($("#useHotGroups").checked) recomputeHotGroups(); });

  function hardBudgetSeconds(sel){
    if(sel === "2") return 120;
    if(sel === "5") return 300;
    if(sel === "10") return 600;
    if(sel === "15") return 900;
    if(sel === "30") return 1800;
    return Infinity;
  }

  function recomputeHotGroups(){
    if(!g_draws.length){ g_hotGroups=[]; text($("#hotInfo"),"aktiv: kein Archiv"); return; }
    const k=+($("#hotK").value||2);
    let topN=Math.max(5,Math.min(1000,+($("#hotTopN").value||30)));
    const level=$("#searchLevel").value||"normal";
    // F√ºr Hot-Paare/F√ºnfer immer das gesamte Archiv nutzen
    let win = g_draws.length;
    const LEVELS={ normal:{winMul:1.2, topMul:1.2}, medium:{winMul:1.6, topMul:1.8}, hard:{winMul:2.2, topMul:2.5} };
    const L=LEVELS[level]||LEVELS.normal;
    // Erweitere Top N je nach Stufe
    topN=Math.floor(topN*L.topMul);

    const hardSel = ($("#searchLevel").value==="hard");
    const budgetSec = (!hardSel) ? 0 : hardBudgetSeconds($("#hotHardBudget").value);

    const fromIdx=0;
    const slice=g_draws.slice(fromIdx);

    if(hotWorker){ try{ hotWorker.terminate(); }catch{} hotWorker=null; }
    const workerCode = `
      let STOP=false;
      function combIter(arr,k,cb){
        const n=arr.length; if(k>n) return;
        const idx=Array.from({length:k},(_,i)=>i);
        while(true){
          cb(idx.map(i=>arr[i]));
          let i=k-1;
          while(i>=0 && idx[i]===i+n-k) i--;
          if(i<0) break;
          idx[i]++;
          for(let j=i+1;j<k;j++) idx[j]=idx[j-1]+1;
        }
      }
      function spaceSavingUpdate(store, cap, key){
        if(store.has(key)){ store.set(key, store.get(key)+1); return; }
        if(store.size < cap){ store.set(key, 1); return; }
        const toDel=[];
        for(const [kk,v] of store){ const nv=v-1; if(nv<=0) toDel.push(kk); else store.set(kk,nv); }
        for(const kk of toDel) store.delete(kk);
      }
      self.onmessage = ev=>{
        const {draws,k,topN,budgetSec,mode} = ev.data;
        const nDraws = draws.length;
        const t0=performance.now();
        let processed=0, lastPing=0;

        function ping(total){ self.postMessage({type:'progress', done:processed, total, elapsed:(performance.now()-t0)/1000}); }

        if(k<=4 || !Number.isFinite(budgetSec) || budgetSec===0 || mode!=='max'){
          const counts = new Map();
          const warmMax=Math.min(30,nDraws); let warmT0=performance.now();
          for(let d=0; d<warmMax; d++){
            combIter(draws[d],k,(combo)=>{ const key=combo.join('-'); counts.set(key,(counts.get(key)||0)+1); });
          }
          const rate = warmMax / ((performance.now()-warmT0)/1000 || 0.001);
          let targetDraws = nDraws;
          if(Number.isFinite(budgetSec) && budgetSec>0){ targetDraws = Math.max(warmMax, Math.min(nDraws, Math.floor(rate*budgetSec))); }
          for(let d=warmMax; d<targetDraws; d++){
            combIter(draws[d],k,(combo)=>{ const key=combo.join('-'); counts.set(key,(counts.get(key)||0)+1); });
            processed=d+1;
            if(processed-lastPing>=10){ lastPing=processed; ping(targetDraws); }
            if(STOP) break;
          }
          const items=Array.from(counts.entries()).sort((a,b)=> b[1]-a[1] || (a[0]<b[0]?-1:1));
          const top = items.slice(0, topN).map(([key,count])=>({key,count}));
          self.postMessage({type:'done', top, total:processed});
          return;
        }
        const cap = Math.max(5*topN, 5000);
        const store = new Map();
        for(let d=0; d<nDraws; d++){
          combIter(draws[d],5,(combo)=>{ spaceSavingUpdate(store, cap, combo.join('-')); });
          processed=d+1;
          if(processed-lastPing>=10){ lastPing=processed; ping(nDraws); }
          if(STOP) break;
        }
        const candidates = Array.from(store.keys());
        const candSet = new Set(candidates);
        const exact = new Map();
        processed=0; lastPing=0;
        const total2 = nDraws;
        for(let d=0; d<nDraws; d++){
          combIter(draws[d],5,(combo)=>{
            const key=combo.join('-');
            if(candSet.has(key)) exact.set(key,(exact.get(key)||0)+1);
          });
          processed=d+1;
          if(processed-lastPing>=10){ lastPing=processed; self.postMessage({type:'progress2', pass:2, done:processed, total:total2, elapsed:(performance.now()-t0)/1000}); }
          if(STOP) break;
        }
        const items=Array.from(exact.entries()).sort((a,b)=> b[1]-a[1] || (a[0]<b[0]?-1:1));
        const top = items.slice(0, topN).map(([key,count])=>({key,count}));
        self.postMessage({type:'done', top, total:nDraws});
      };
      self.onmessagecancel = ()=>{ STOP=true; };
    `;
    const blob = new Blob([workerCode], {type:"text/javascript"});
    hotWorker = new Worker(URL.createObjectURL(blob));
    hotWorker.onmessage = (ev)=>{
      const data = ev.data||{};
      if(data.type==="progress"){ text($("#hotInfo"), `Pass 1‚Ä¶ ${data.done}/${data.total} Ziehungen ¬∑ ${(data.elapsed||0).toFixed(1)}s`); $("#hotProg").style.display=""; $("#hotProg").value = data.total ? (data.done/data.total) : 0; }
      else if(data.type==="progress2"){ text($("#hotInfo"), `Pass 2‚Ä¶ ${data.done}/${data.total} Ziehungen ¬∑ ${(data.elapsed||0).toFixed(1)}s`); $("#hotProg").style.display=""; $("#hotProg").value = data.total ? (data.done/data.total) : 0; }
      else if(data.type==="done"){
        $("#hotProg").style.display="none";
        g_hotGroups = (data.top||[]).map(x=>({ combo: x.key.split('-').map(n=>+n), count: x.count }));
        text($("#hotInfo"), `Top ${g_hotGroups.length} Gruppen (k=${$("#hotK").value}) ermittelt.`);
      }
    };
    $("#hotProg").style.display="";
    text($("#hotInfo"), "l√§uft‚Ä¶");
    hotWorker.postMessage({ draws: slice, k, topN, budgetSec, mode: "max" });
  }
    } // ‚Äî Ende recomputeHotGroups

  /* ===================== RNG (deterministisch, Seed optional lang) ===================== */
  function mkSeededRng(seedStr){
    // Akzeptiert sehr lange numerische Strings ‚Äì faltet sie deterministisch
    const s = String(seedStr||"1").replace(/\D+/g,"") || "1";
    let h1=0x9e3779b9, h2=0x85ebca6b, h3=0xc2b2ae35, h4=0x27d4eb2f;
    for(let i=0;i<s.length;i++){
      const x = s.charCodeAt(i) - 48;
      h1 = (h1 ^ x) * 0x85ebca6b; h1|=0;
      h2 = (h2 + h1) * 0xc2b2ae35; h2|=0;
      h3 = (h3 ^ h2) * 0x27d4eb2f; h3|=0;
      h4 = (h4 + h3) | 0;
    }
    function xorshift(){ h4 ^= h4<<13; h4 ^= h4>>>17; h4 ^= h4<<5; return (h4>>>0)/0xFFFFFFFF; }
    return ()=> xorshift();
  }

  /* ===================== Archiv-Gewichte (hot/cold/mix/neutral) ===================== */
  function buildArchiveWeights(mode, A, B, lastWindow){ // lastWindow: 'all' | number
    const n=B-A+1;
    const freq=Array(n).fill(0);
    const start = (!g_draws.length) ? 0 :
      (lastWindow && lastWindow!=='all' ? Math.max(0, g_draws.length - (+lastWindow)) : 0);
    for(let d=start; d<g_draws.length; d++){
      for(const z of g_draws[d]){
        if(z>=A && z<=B) freq[z-A]++;
      }
    }
    const maxF = Math.max(1, ...freq);
    const minF = Math.min(...freq);
    const norm = freq.map(f=> f/maxF);
    const inv  = freq.map(f=> (maxF - (f-minF)) / Math.max(1,(maxF-minF||1)));
    // neutral = 1, hot = norm^1.2, cold = inv^1.2, mix = 0.5*(hot+cold)
    const pow = 1.2;
    const hot  = norm.map(x=> Math.pow(x||0.0001,pow));
    const cold = inv.map(x=> Math.pow(x||0.0001,pow));
    if(mode==="hot")  return hot;
    if(mode==="cold") return cold;
    if(mode==="mix")  return hot.map((x,i)=> 0.5*(x + cold[i]));
    return Array(n).fill(1); // neutral
  }

  /* ===================== Smart10 Heuristik & Generator ===================== */
  const SMART_CFG = {
    adj_w: 4.0,         // Adjazenz-Strafe (|a-b|==1)
    pair_w: 1.0,        // Paar-Wiederverwendungsstrafe
    cover_pair_w: 2.0,  // f√ºr smart10-cover st√§rker
    spread_bonus: 0.15, // Belohnung f√ºr gro√üe Abst√§nde in einer Variante
    targetTol: 1.0,     // Toleranz gegen Zielh√§ufigkeit
    maxSteps: 5000      // lokale Verbesserung (2-Swap) upper bound
  };

  function hasRunOf4(nums){ // vermeidet 4+ aufeinanderfolgende Werte
    let run=1;
    for(let i=1;i<nums.length;i++){
      if(nums[i]===nums[i-1]+1){ run++; if(run>=4) return true; }
      else run=1;
    }
    return false;
  }

  function pairKey(a,b){ return a<b ? (a<<10)|b : (b<<10)|a; }

  function ticketScore(ticket, counts, A, B, weights, pairUsed, cfg){
    const k=ticket.length;
    let score=0;
    // Unter-/√úberdeckung
    for(const z of ticket){
      const idx=z-A;
      const w=(weights[idx]||1);
      const c=(counts.get(z)||0);
      // leicht belohnen, wenn unter Ziel, leicht strafen, wenn dr√ºber
      score -= w * (1.0 / (1 + c));
    }
    // Adjazenz
    for(let i=1;i<k;i++){
      if(Math.abs(ticket[i]-ticket[i-1])===1) score += cfg.adj_w;
    }
    // Spread (gr√∂√üere Distanz zwischen aufeinanderfolgenden Zahlen)
    let spread=0; for(let i=1;i<k;i++) spread += Math.abs(ticket[i]-ticket[i-1]);
    score -= cfg.spread_bonus * (spread / (k-1));
    // Paare, die historisch schon oft gemeinsam genutzt wurden
    for(let i=0;i<k;i++) for(let j=i+1;j<k;j++){
      const pk = pairKey(ticket[i], ticket[j]);
      score += (pairUsed.get(pk)||0) * cfg.pair_w * 0.5;
    }
    // Run-of-4 hart bestrafen
    if(hasRunOf4(ticket)) score += 50;
    return score;
  }

  async function generateSmartVariants(mode, want, progressCb){
    const S=10; // Smart-Generator arbeitet auf Typ 10
    const k=S;
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const maxOv=+$("#maxOv").value;
    const seedStr = $("#seed").value || "1";
    const rng = mkSeededRng(seedStr);
    const wMode = (mode==="smart10-hot") ? "hot" :
                  (mode==="smart10-cold") ? "cold" :
                  (mode==="smart10-mix") ? "mix" : "neutral";
    const weights = buildArchiveWeights(wMode, A, B, 'all');
    const counts = new Map();
    const pairUsed = new Map();
    const variants=[];
    // Zielh√§ufigkeit grob
    const target = (want*k)/(B-A+1);
    const tMax = Math.ceil(target + SMART_CFG.targetTol);

    function candidateScoreAdd(cur, z){
      let score=0;
      // Gewicht / Unterdeckung
      const idx=z-A;
      const w=(weights[idx]||1);
      const c=(counts.get(z)||0);
      score -= w * (1.0 / (1 + c));
      // N√§he zu bestehenden Zahlen
      const arr=Array.from(cur).sort((x,y)=>x-y);
      for(let i=0;i<arr.length;i++){
        const x=arr[i];
        if(Math.abs(z-x)===1) score += SMART_CFG.adj_w;
        if(x<z){ const pk=pairKey(x,z); score += (pairUsed.get(pk)||0) * SMART_CFG.pair_w; }
        else   { const pk=pairKey(z,x); score += (pairUsed.get(pk)||0) * SMART_CFG.pair_w; }
      }
      return score;
    }

    for(let t=0; t<want; t++){
      const cur=new Set();
      let guard=0;
      while(cur.size<k && guard<5000){
        guard++;
        let bestZ=null, bestScore=Infinity;
        // Kandidaten-Sampling (beschleunigt): ziehe 200 zuf√§llige Kandidaten, nimm den besten
        for(let it=0; it<200; it++){
          const z=A + Math.floor(rng()*(B-A+1));
          if(cur.has(z)) continue;
          if((counts.get(z)||0) >= tMax) continue;
          // Overlap-Pr√ºfung (gegen alle bisherigen Varianten)
          let bad=false;
          for(const v of variants){
            let ov=0; for(const x of v) if(x===z || (cur.has(x))) { if(x===z||cur.has(x)) ov++; }
            if(ov > maxOv){ bad=true; break; }
          }
          if(bad) continue;
          const s = candidateScoreAdd(cur,z);
          if(s<bestScore){ bestScore=s; bestZ=z; }
        }
        // Fallback linear, falls Sampling nichts fand
        if(bestZ===null){
          for(let z=A; z<=B; z++){
            if(cur.has(z)) continue;
            if((counts.get(z)||0) >= tMax) continue;
            let bad=false, ovAdd=0;
            for(const v of variants){
              let ov=0;
              for(const x of v){ if(cur.has(x)) ov++; }
              if(v.includes(z)) ov++;
              if(ov>maxOv){ bad=true; break; }
              ovAdd=Math.max(ovAdd, ov);
            }
            if(bad) continue;
            const s=candidateScoreAdd(cur,z) + 0.001*ovAdd;
            if(s<bestScore){ bestScore=s; bestZ=z; }
          }
        }
        if(bestZ==null) break;
        cur.add(bestZ);
      }
      const arr=uniqSorted(Array.from(cur));
      // Notbremse gegen Run-of-4: kleine lokale Ver√§nderung
      if(hasRunOf4(arr)){
        for(let tries=0;tries<200;tries++){
          const idx=Math.floor(rng()*arr.length);
          let nz=A + Math.floor(rng()*(B-A+1));
          if(arr.includes(nz)) continue;
          const tmp=arr.slice(); tmp[idx]=nz; tmp.sort((x,y)=>x-y);
          if(!hasRunOf4(tmp)){ arr.splice(0,arr.length,...tmp); break; }
        }
      }
      // Register counts + pairUsed
      for(const z of arr){ counts.set(z,(counts.get(z)||0)+1); }
      for(let i=0;i<arr.length;i++) for(let j=i+1;j<arr.length;j++){
        const pk=pairKey(arr[i],arr[j]); pairUsed.set(pk,(pairUsed.get(pk)||0)+1);
      }
      variants.push(arr);
      if(progressCb && t%5===0){ progressCb((t+1)/want); await new Promise(r=>setTimeout(r,0)); }
    }

    // Lokale Verbesserung (2-Swap) um Paardoppler/Adjazenz zu verringern
    const cfg = Object.assign({}, SMART_CFG, (mode==="smart10-cover"? {pair_w:SMART_CFG.cover_pair_w}:{}) );
    let steps=0, improved=true;
    while(improved && steps<SMART_CFG.maxSteps){
      improved=false; steps++;
      // w√§hle zwei Tickets
      const i=Math.floor(rng()*variants.length);
      const j=Math.floor(rng()*variants.length);
      if(i===j) continue;
      const ti=variants[i].slice();
      const tj=variants[j].slice();
      // w√§hle je ein Element
      const ai=Math.floor(rng()*ti.length);
      const aj=Math.floor(rng()*tj.length);
      const zi=ti[ai], zj=tj[aj];
      if(zi===zj) continue;
      ti[ai]=zj; tj[aj]=zi;
      ti.sort((a,b)=>a-b); tj.sort((a,b)=>a-b);
      // √úberlapp pr√ºfen (mit allen anderen)
      function maxOverlapOf(v){
        let mo=0;
        for(let w=0; w<variants.length; w++){
          if(w===i||w===j) continue;
          let ov=0;
          const set = new Set(variants[w]);
          for(const x of v) if(set.has(x)) ov++;
          if(ov>mo) mo=ov;
        }
        return mo;
      }
      const mo_i = maxOverlapOf(ti), mo_j = maxOverlapOf(tj);
      if(mo_i>maxOv || mo_j>maxOv) continue;

      // Score vorher/nachher grob vergleichen
      const s_before = ticketScore(variants[i], counts, A, B, weights, pairUsed, cfg)
                     + ticketScore(variants[j], counts, A, B, weights, pairUsed, cfg);
      const s_after  = ticketScore(ti, counts, A, B, weights, pairUsed, cfg)
                     + ticketScore(tj, counts, A, B, weights, pairUsed, cfg);
      if(s_after < s_before){
        variants[i]=ti; variants[j]=tj;
        improved=true;
      }
      if(steps%200===0) await new Promise(r=>setTimeout(r,0));
    }
    return variants;
  }

  /* ===================== Monte-Carlo-Simulation ===================== */
  async function simulateHitRates(variants, runs=20000, progressCb){
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const pool=Array.from({length:B-A+1},(_,i)=>A+i);
    const K=variants[0]?.length||10;
    const vsets=variants.map(v=> new Set(v));
    const hist=Array(K+1).fill(0);
    let ge6=0;
    for(let r=0;r<runs;r++){
      // 20 aus [A..B] ohne Zur√ºcklegen (Fisher-Yates partiell)
      const arr=pool.slice();
      for(let i=0;i<20;i++){
        const j=i + Math.floor(Math.random()*(arr.length-i));
        const tmp=arr[i]; arr[i]=arr[j]; arr[j]=tmp;
      }
      const drawn=new Set(arr.slice(0,20));
      let best=0;
      for(const s of vsets){
        let hit=0; for(const x of s) if(drawn.has(x)) hit++;
        if(hit>best) best=hit;
      }
      hist[best]++;
      if(best>=6) ge6++;
      if(progressCb && (r%500===0)) { progressCb(r/runs); await new Promise(r=>setTimeout(r,0)); }
    }
    return { hist, pBestGE6: ge6/runs, runs };
  }

  /* ===================== Ergebnisse rendern & Tools ===================== */
  function renderResults(list){
    const el=$("#results"); el.innerHTML="";
    list.forEach((nums,idx)=>{
      const span=document.createElement("div");
      span.className="resItem";
      span.innerHTML = `<span class="badge">#${idx+1}</span>
                        <span class="resNums">${nums.map(n=>String(n).padStart(2," ")).join(" ")}</span>`;
      el.appendChild(span);
    });
  }
  function combosToCSV(list){ return list.map(a=>a.join(",")).join("\n"); }
  function downloadText(name, textData){
    const blob=new Blob([textData],{type:"text/plain;charset=utf-8"});
    const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=name; a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  }

  /* ===================== Generator-Bedienung ===================== */
  function currentGenMode(){ return $("#genMode").value; }
  async function runGenerator(){
    const mode=currentGenMode();
    const want=+$("#want").value||10;
    $("#genProg").style.display=""; $("#genProg").value=0;
    text($("#genInfo"), `Starte: ${mode} ¬∑ ${want} Varianten ‚Ä¶`);
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const S=getS();
    let variants=[];
    if(mode.startsWith("smart10")){
      if(S!==10) text($("#genInfo"), "Hinweis: Smart10 verwendet fest KENO-Typ 10 (unabh√§ngig von der Einstellungen).");
      variants = await generateSmartVariants(mode, want, p=>$("#genProg").value=p);
    }else if(mode==="random"){
      // zuf√§llig (ohne Muster)
      for(let i=0;i<want;i++){
        const arr=[]; const used=new Set();
        while(arr.length<S){
          const z=A+Math.floor(Math.random()*(B-A+1));
          if(used.has(z)) continue;
          used.add(z); arr.push(z);
        }
        arr.sort((x,y)=>x-y);
        if(hasRunOf4(arr)){ i--; continue; } // neu ziehen
        variants.push(arr);
        if(i%5===0){ $("#genProg").value=(i+1)/want; await new Promise(r=>setTimeout(r,0)); }
      }
    }else if(mode==="freq"){
      const weights = buildArchiveWeights("hot",A,B,'all');
      for(let i=0;i<want;i++){
        const used=new Set();
        while(used.size<S){
          // Roulette Wheel
          let acc=0, pick=Math.random()*weights.reduce((a,b)=>a+b,0);
          let z=A;
          for(let idx=0; idx<weights.length; idx++){
            acc+=weights[idx];
            if(acc>=pick){ z=A+idx; break; }
          }
          if(!used.has(z)) used.add(z);
          if(used.size>10000) break;
        }
        const arr=uniqSorted(Array.from(used));
        if(arr.length!==S || hasRunOf4(arr)){ i--; continue; }
        variants.push(arr);
        if(i%5===0){ $("#genProg").value=(i+1)/want; await new Promise(r=>setTimeout(r,0)); }
      }
    }else{
      // andere √§ltere Modi entfernt / nicht verwendet
      text($("#genInfo"), "Modus nicht implementiert.");
      $("#genProg").style.display="none";
      return;
    }

    renderResults(variants);
    $("#genProg").style.display="none";
    text($("#genInfo"), `Fertig: ${variants.length} Varianten.`);

    // Simulation
    text($("#resultStatus"), "Starte Monte-Carlo-Simulation (10k)‚Ä¶");
    $("#resultStatus").style.display="";
    const sim = await simulateHitRates(variants, 10000, p=>{ $("#resultStatus").textContent = `Simulation‚Ä¶ ${(100*p).toFixed(0)}%`; });
    const histTxt = sim.hist.map((c,i)=> i.toString().padStart(2," ")+" ‚Üí "+c.toString().padStart(6," ")).join("\n");
    const rep = `P(best ‚â• 6) = ${(100*sim.pBestGE6).toFixed(2)}%\nHistogramm best Hits:\n${histTxt}`;
    $("#resultStatus").textContent = rep;

    // Ergebnis sichern f√ºr Export-Buttons
    $("#results")._variants = variants;
  }

  $("#go").addEventListener("click", ()=>{ runGenerator().catch(e=>{ $("#genProg").style.display="none"; text($("#genInfo"), "Fehler: "+(e?.message||e)); }); });
  $("#save").addEventListener("click", ()=>{
    const v=$("#results")._variants||[];
    if(!v.length){ alert("Keine Ergebnisse."); return; }
    downloadText("keno_variants.csv", combosToCSV(v));
  });
  $("#copyCombos").addEventListener("click", async ()=>{
    const v=$("#results")._variants||[];
    if(!v.length){ alert("Keine Ergebnisse."); return; }
    const t=v.map(a=>a.join(" ")).join("\n");
    try{ await navigator.clipboard.writeText(t); alert("Kopiert!"); }catch{ alert("Konnte nicht kopieren."); }
  });

  /* ===================== Seed-Tools ===================== */
  function cryptoSeed(){
    const a=new Uint32Array(4); crypto.getRandomValues(a);
    return String(a[0])+String(a[1])+String(a[2])+String(a[3]);
  }
  function fibSeed(){
    let a=1n,b=1n; for(let i=0;i<200;i++){ const t=a+b; a=b; b=t; }
    return (a%10000000000000000n).toString();
  }
  function primeSeed(){
    // sehr vereinfachte Primzahl-Faltung
    const p=[2,3,5,7,11,13,17,19,23,29,31,37]; let x=1n;
    for(const v of p){ x = (x*BigInt(v)) % 10000000000000000n; }
    return x.toString();
  }
  $("#seedRand").addEventListener("click", ()=>{
    const f=$("#seedFormula").value;
    const v = f==="fib" ? fibSeed() : f==="prime" ? primeSeed() : cryptoSeed();
    $("#seed").value = v;
  });

  /* ===================== Omega & Mother Mode ‚Äì UI & Logik ===================== */
  // Panel unter Ergebnisse einf√ºgen (isoliert)
  (function addOmegaMotherPanels(){
    const host=document.querySelector(".box");
    const wrap=document.createElement("div");
    wrap.innerHTML = `
      <div class="panel" id="p-omega" style="border-left:6px solid #8b5cf6">
        <div class="ph"><span class="emoji">üß¨</span><h2 style="margin:0">Omega Modus ‚Äî Blackbox</h2><span class="pill">isoliert</span></div>
        <div class="row">
          <div><label>Keno-Typ</label><select id="omegaType"><option value="10" selected>Typ 10</option></select></div>
          <div><label>Varianten</label><input type="number" id="omegaVariants" value="50" min="1" max="2000"></div>
          <div><label>Strategie</label>
            <select id="omegaStrategy">
              <option value="hybrid" selected>hybrid</option>
              <option value="sa">sa (Simulated Annealing)</option>
              <option value="genetic">genetic</option>
              <option value="ilp">ilp (Skizze, heuristisch)</option>
            </select>
          </div>
          <div><label>Seed (optional)</label><input type="text" id="omegaSeed" placeholder="z. B. 1234567890123" pattern="\\d*" inputmode="numeric"></div>
        </div>
        <div class="row">
          <label class="pill" style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="omegaIsolate" checked> Omega isoliert alles andere</label>
          <button id="omegaRun" class="primary">Omega starten</button>
          <button id="omegaExit" class="ghost">Exit Omega</button>
          <button id="omegaExport" class="secondary">Export (JSON)</button>
        </div>
        <div style="margin-top:6px">
          <label>Fortschritt</label>
          <progress id="omegaProg" value="0" max="1" style="display:none"></progress>
          <div id="omegaInfo" class="status" style="margin-top:6px">bereit</div>
          <div id="omegaReport" class="status" style="margin-top:6px;display:none"></div>
        </div>
        <div class="hint" style="margin-top:6px">Dieses Tool optimiert Verteilungen; Lotterien sind zuf√§llig ‚Äî es gibt keine Garantie.</div>
      </div>

      <div class="panel" id="p-mother" style="border-left:6px solid #10b981">
        <div class="ph"><span class="emoji">üß∞</span><h2 style="margin:0">Mother Mode ‚Äî Archiv-optimierter Generator</h2><span class="pill">abgekapselt</span></div>
        <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="motherOn"> <span>Mother Mode einschalten</span></label>
        <div class="row">
          <div><label>Varianten</label><input type="number" id="motherVariants" value="50" min="1" max="2000"></div>
          <div><label>Seed (optional)</label><input type="text" id="motherSeed" placeholder="Seed (Zahlen)" pattern="\\d*" inputmode="numeric"></div>
          <div><label>Gewicht-Strategie</label>
            <select id="motherW">
              <option value="neutral">neutral</option>
              <option value="hot" selected>hot</option>
              <option value="cold">cold</option>
              <option value="mix">mix</option>
            </select>
          </div>
          <div><label>Vergleichsfenster</label>
            <select id="motherWin">
              <option value="50" selected>letzte 50</option>
              <option value="100">letzte 100</option>
              <option value="all">alle</option>
            </select>
          </div>
        </div>
        <div class="row">
          <button id="motherRun" class="primary">Mother-Run starten</button>
          <button id="motherExit" class="ghost">Exit Mother</button>
          <button id="motherExport" class="secondary">Export (JSON)</button>
        </div>
        <div style="margin-top:6px">
          <label>Fortschritt</label>
          <progress id="motherProg" value="0" max="1" style="display:none"></progress>
          <div id="motherInfo" class="status" style="margin-top:6px">bereit</div>
          <div id="motherReport" class="status" style="margin-top:6px;display:none"></div>
        </div>
        <div class="hint" style="margin-top:6px">Dieses Tool optimiert Verteilungen; Lotterien sind zuf√§llig ‚Äî es gibt keine Garantie.</div>
      </div>
    `;
    host.appendChild(wrap.firstElementChild);
    host.appendChild(wrap.lastElementChild);
  })();

  /* ===================== Omega/Mother ‚Äì Isolations-Logik ===================== */
  function setIsolation(on, keepIds){
    const ids = ["p-archiv","p-settings","p-pattern","p-hot","p-gen","p-range-rules","p-stats","p-analyse","p-favs","p-results","p-omega","p-mother"];
    const keep=new Set(keepIds||[]);
    ids.forEach(id=>{
      const el=document.getElementById(id);
      if(!el) return;
      if(keep.has(id)) el.style.display="";
      else el.style.display = on ? (keep.has(id)?"":"none") : "";
    });
  }

  /* ===================== Omega ‚Äì Ablauf (hybrid kompakt) ===================== */
  async function runOmega(){
    const want=+$("#omegaVariants").value||50;
    const seed=$("#omegaSeed").value||$("#seed").value||"1";
    const strat=$("#omegaStrategy").value;
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const info=$("#omegaInfo"), prog=$("#omegaProg"), rep=$("#omegaReport");
    info.textContent="Init‚Ä¶"; prog.style.display=""; prog.value=0; rep.style.display="none";
    // 1) Greedy (Smart10-mix)
    let variants = await generateSmartVariants("smart10-mix", want, p=>{ prog.value = 0.25*p; info.textContent=`Greedy‚Ä¶ ${(25*p)|0}%`; });
    // 2) SA/Genetic rudiment√§r (leichte Perturbation)
    if(strat==="hybrid" || strat==="sa" || strat==="genetic"){
      const rng=mkSeededRng(seed);
      const steps = strat==="sa" ? 4000 : strat==="genetic" ? 3000 : 2500;
      for(let s=0; s<steps; s++){
        // kleiner Tausch
        const i=Math.floor(rng()*variants.length), j=Math.floor(rng()*variants.length);
        if(i===j) continue;
        const ti=variants[i].slice(), tj=variants[j].slice();
        const ai=Math.floor(rng()*ti.length), aj=Math.floor(rng()*tj.length);
        const zi=ti[ai], zj=tj[aj]; if(zi===zj) continue;
        ti[ai]=zj; tj[aj]=zi; ti.sort((a,b)=>a-b); tj.sort((a,b)=>a-b);
        // akzeptiere, wenn keine 4er-Run und maxOv ok
        const maxOv=+$("#maxOv").value;
        function ok(v){
          if(hasRunOf4(v)) return false;
          for(const u of variants){
            if(u===v) continue; let ov=0; const ss=new Set(u); for(const x of v) if(ss.has(x)) ov++;
            if(ov>maxOv) return false;
          }
          return true;
        }
        if(ok(ti) && ok(tj)){ variants[i]=ti; variants[j]=tj; }
        if(s%200===0){ prog.value = 0.25 + 0.35*(s/steps); info.textContent=`Verbesserung‚Ä¶ Schritt ${s}/${steps}`; await new Promise(r=>setTimeout(r,0)); }
      }
    }
    // 3) Lokale Verbesserung (bereits in Smart enthalten); hier nur finaler Polish
    variants = variants.map(v=> v.slice().sort((a,b)=>a-b));
    prog.value=0.65; info.textContent="Feinschliff‚Ä¶";
    await new Promise(r=>setTimeout(r,0));

    // 4) Simulation + Report
    info.textContent="Simulation (10k)‚Ä¶"; prog.value=0.7;
    const sim = await simulateHitRates(variants, 10000, p=>{ prog.value = 0.7 + 0.3*p; });
    const counts = new Map(); for(const v of variants) for(const z of v) counts.set(z,(counts.get(z)||0)+1);
    const all=Array.from(counts.values()); const mn=Math.min(...all), mx=Math.max(...all), av=(all.reduce((a,b)=>a+b,0)/all.length)||0;
    // Pair coverage
    const seenPairs = new Set();
    for(const v of variants) for(let i=0;i<v.length;i++) for(let j=i+1;j<v.length;j++) seenPairs.add(pairKey(v[i],v[j]));
    const totalPairs = (B-A+1)*((B-A)/2); // grobe Obergrenze (nur Indikativ)
    const pairPct = Math.min(100, 100*seenPairs.size/Math.max(1,totalPairs));

    const histTxt = sim.hist.map((c,i)=> i.toString().padStart(2," ")+" ‚Üí "+c.toString().padStart(6," ")).join("\n");
    const repTxt = [
      `Varianten: ${variants.length} ¬∑ Bereich ${A}-${B}`,
      `Frequenz pro Zahl (min/avg/max): ${mn}/${av.toFixed(2)}/${mx}`,
      `Einzigartige Paare: ${seenPairs.size} (~${pairPct.toFixed(3)}% grob)`,
      `P(best ‚â• 6) = ${(100*sim.pBestGE6).toFixed(2)}%`,
      `Histogramm best Hits:\n${histTxt}`
    ].join("\n");
    rep.style.display=""; rep.textContent = repTxt;

    $("#results")._variants = variants;
    prog.style.display="none";
    info.textContent="Omega fertig.";
    renderResults(variants);
  }

  $("#omegaRun").addEventListener("click", ()=>{
    if($("#omegaIsolate").checked) setIsolation(true, new Set(["p-archiv","p-omega"]));
    runOmega().catch(e=>{ $("#omegaProg").style.display="none"; $("#omegaInfo").textContent="Fehler: "+(e?.message||e); });
  });
  $("#omegaExit").addEventListener("click", ()=> setIsolation(false));
  $("#omegaExport").addEventListener("click", ()=>{
    const v=$("#results")._variants||[];
    if(!v.length){ alert("Keine Omega-Ergebnisse."); return; }
    const meta = { mode:"omega", ts:Date.now(), range:[+$("#rangeFrom").value,+$("#rangeTo").value], maxOv:+$("#maxOv").value };
    downloadText(`omega_variants_${new Date().toISOString().slice(0,10).replace(/-/g,"")}.json`, JSON.stringify({meta, variants:v}, null, 2));
  });

  /* ===================== Mother Mode ‚Äì Ablauf ===================== */
  async function runMother(){
    const want=+$("#motherVariants").value||50;
    const seed=$("#motherSeed").value||$("#seed").value||"1";
    const wMode=$("#motherW").value||"hot";
    const win=$("#motherWin").value||"50";
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const info=$("#motherInfo"), prog=$("#motherProg"), rep=$("#motherReport");
    info.textContent="Init‚Ä¶"; prog.style.display=""; prog.value=0; rep.style.display="none";
    // Mother: Smart10 mit Archivgewichten (Fenster) + st√§rkere Paar-Entkopplung
    const prevAdj = SMART_CFG.adj_w, prevPair=SMART_CFG.pair_w;
    SMART_CFG.adj_w = 4.5; SMART_CFG.pair_w = 1.3;
    // tempor√§r eigene build-weights mit Fenster
    const weights = buildArchiveWeights(wMode, A, B, (win==='all'?'all':+win));
    // kurzzeitig ‚Äûinjecten‚Äú, indem generateSmartVariants auf mix basiert, aber wir ersetzen weights per Closure
    const _buildArchiveWeights = buildArchiveWeights;
    window.buildArchiveWeights = ()=>weights.slice(); // Hack: innerhalb des Calls neutralisieren
    let variants = await generateSmartVariants("smart10", want, p=>{ prog.value = p*0.85; info.textContent=`Mother: ${(100*p)|0}%`; });
    window.buildArchiveWeights = _buildArchiveWeights;
    SMART_CFG.adj_w = prevAdj; SMART_CFG.pair_w = prevPair;

    // Simulation und Report
    info.textContent="Simulation (10k)‚Ä¶"; prog.value=0.9;
    const sim = await simulateHitRates(variants, 10000, p=>{ prog.value = 0.9 + 0.1*p; });
    const counts = new Map(); for(const v of variants) for(const z of v) counts.set(z,(counts.get(z)||0)+1);
    const all=Array.from(counts.values()); const mn=Math.min(...all), mx=Math.max(...all), av=(all.reduce((a,b)=>a+b,0)/all.length)||0;
    const seenPairs = new Set();
    for(const v of variants) for(let i=0;i<v.length;i++) for(let j=i+1;j<v.length;j++) seenPairs.add(pairKey(v[i],v[j]));
    const totalPairs = (B-A+1)*((B-A)/2);
    const pairPct = Math.min(100, 100*seenPairs.size/Math.max(1,totalPairs));
    const histTxt = sim.hist.map((c,i)=> i.toString().padStart(2," ")+" ‚Üí "+c.toString().padStart(6," ")).join("\n");
    const repTxt = [
      `Varianten: ${variants.length} ¬∑ Bereich ${A}-${B}`,
      `Frequenz pro Zahl (min/avg/max): ${mn}/${av.toFixed(2)}/${mx}`,
      `Einzigartige Paare: ${seenPairs.size} (~${pairPct.toFixed(3)}% grob)`,
      `P(best ‚â• 6) = ${(100*sim.pBestGE6).toFixed(2)}%`,
      `Histogramm best Hits:\n${histTxt}`,
      `Fenster-Vergleich: ${win}`
    ].join("\n");
    rep.style.display=""; rep.textContent = repTxt;
    $("#results")._variants = variants;
    prog.style.display="none";
    info.textContent="Mother fertig.";
    renderResults(variants);
  }

  $("#motherOn").addEventListener("change", ()=>{
    if($("#motherOn").checked){ setIsolation(true, new Set(["p-archiv","p-mother"])); }
    else setIsolation(false);
  });
  $("#motherRun").addEventListener("click", ()=>{
    if(!g_draws.length){ alert("Bitte zuerst Archiv laden."); return; }
    setIsolation(true, new Set(["p-archiv","p-mother"]));
    runMother().catch(e=>{ $("#motherProg").style.display="none"; $("#motherInfo").textContent="Fehler: "+(e?.message||e); });
  });
  $("#motherExit").addEventListener("click", ()=>{ $("#motherOn").checked=false; setIsolation(false); });
  $("#motherExport").addEventListener("click", ()=>{
    const v=$("#results")._variants||[];
    if(!v.length){ alert("Keine Mother-Ergebnisse."); return; }
    const meta = { mode:"mother", ts:Date.now(), range:[+$("#rangeFrom").value,+$("#rangeTo").value], window:$("#motherWin").value, weights:$("#motherW").value, maxOv:+$("#maxOv").value };
    downloadText(`mother_variants_${new Date().toISOString().slice(0,10).replace(/-/g,"")}.json`, JSON.stringify({meta, variants:v}, null, 2));
  });

  /* ===================== Statistik berechnen (UI-Panel) ===================== */
  $("#calcStats").addEventListener("click", ()=>{
    if(!g_draws.length){ alert("Bitte zuerst Archiv laden."); return; }
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const win = $("#statsWindow").value;
    const stats = (function(){
      const n=B-A+1, freq=Array(n).fill(0);
      const start = (win==='all') ? 0 : Math.max(0, g_draws.length - (+win));
      for(let d=start; d<g_draws.length; d++){
        for(const z of g_draws[d]) if(z>=A && z<=B) freq[z-A]++;
      }
      return freq;
    })();
    const items = stats.map((c,i)=>({z:A+i,c})).sort((x,y)=> y.c-x.c || x.z-y.z).slice(0,20);
    const lines = items.map(it=> `${String(it.z).padStart(2," ")} : ${String(it.c).padStart(6," ")}`).join("\n");
    const inf = $("#statsInfo"); inf.style.display=""; inf.textContent = `Top 20 im Bereich ${A}-${B}, Fenster: ${win}`;
    const lst=$("#statsList"); lst.style.display=""; lst.textContent = lines;
  });

  /* ===================== Favoriten rudiment√§r (unver√§ndert) ===================== */
  // (Die bestehenden Favoriten-Funktionen bleiben erhalten ‚Äì hier nur Platzhalter, falls ben√∂tigt.)
    /* ===================== Favoriten (Speichern / Laden / Rendern) ===================== */
  function loadFavorites(){
    try{ return JSON.parse(localStorage.getItem(FAV_KEY)||"[]"); }catch{ return []; }
  }
  function saveFavorites(list){
    try{ localStorage.setItem(FAV_KEY, JSON.stringify(list||[])); }catch{}
  }
  function renderFavorites(){
    const list = loadFavorites();
    const box=$("#favList"); box.innerHTML="";
    list.forEach((it,idx)=>{
      const card=document.createElement("div");
      card.className="favCard";
      const nums = (it.nums||[]).map(n=>String(n).padStart(2," ")).join(" ");
      card.innerHTML = `
        <div class="favHead">
          <div class="favNums mono">${nums}</div>
          <div class="favBtns">
            <button class="secondary" data-act="copy" data-idx="${idx}">üìã</button>
            <button class="secondary" data-act="use" data-idx="${idx}">‚ûï</button>
            <button class="danger" data-act="del" data-idx="${idx}">‚úñ</button>
          </div>
        </div>
        <div class="favNote">${(it.note||"").replace(/</g,"&lt;")}</div>
      `;
      box.appendChild(card);
    });
  }
  $("#favToggle").addEventListener("click", ()=>{
    const el=$("#favList"); const on = (el.style.display!=="none");
    el.style.display = on ? "none" : "";
    try{ localStorage.setItem(FAV_VISIBLE_KEY, on ? "0" : "1"); }catch{}
  });
  $("#favExport").addEventListener("click", ()=>{
    const list = loadFavorites();
    downloadText(`keno_favorites_${new Date().toISOString().slice(0,10).replace(/-/g,"")}.json`, JSON.stringify(list,null,2));
  });
  $("#favClear").addEventListener("click", ()=>{
    if(!confirm("Alle Favoriten wirklich l√∂schen?")) return;
    saveFavorites([]); renderFavorites();
  });
  $("#favImportFile").addEventListener("change", async ()=>{
    const f=$("#favImportFile").files[0]; if(!f) return;
    try{
      const txt = await f.text();
      const obj = JSON.parse(txt);
      if(!Array.isArray(obj)) throw new Error("JSON erwartet Array.");
      saveFavorites(obj); renderFavorites();
    }catch(e){ alert("Import fehlgeschlagen: "+(e?.message||e)); }
  });
  document.getElementById("p-favs").addEventListener("click",(e)=>{
    const btn=e.target.closest("button[data-act]"); if(!btn) return;
    const act=btn.dataset.act, idx=+btn.dataset.idx;
    const list=loadFavorites(); const it=list[idx]; if(!it) return;
    if(act==="copy"){
      const t=(it.nums||[]).join(" ");
      navigator.clipboard.writeText(t).then(()=>alert("Kopiert!")).catch(()=>alert("Konnte nicht kopieren."));
    }else if(act==="use"){
      // f√ºge die Favoriten-Zahlen in die aktuellen Ergebnisse oben ein (prepend)
      const cur = $("#results")._variants || [];
      $("#results")._variants = [uniqSorted(it.nums||[])].concat(cur);
      renderResults($("#results")._variants);
      scrollToNode(document.getElementById("p-results"));
    }else if(act==="del"){
      list.splice(idx,1); saveFavorites(list); renderFavorites();
    }
  });

  /* ===================== Tipp analysieren ===================== */
  function parseTipLine(s){
    return (s.match(/\d+/g)||[]).map(x=>+x).filter(Number.isFinite).sort((a,b)=>a-b);
  }
  $("#checkTip").addEventListener("click", ()=>{
    const arr = parseTipLine($("#tipInput").value);
    if(!arr.length){ alert("Bitte Zahlen eingeben."); return; }
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const v=arr.filter(x=> x>=A && x<=B);
    if(v.length!==arr.length){ alert(`Einige Zahlen liegen au√üerhalb ${A}-${B}.`); }
    const thrA=+$("#thrA").value, thrB=+$("#thrB").value;
    const res=$("#results")._variants||[];
    let overA=[], overB=[];
    res.forEach((w,idx)=>{
      const s=new Set(w); let ov=0; for(const x of v) if(s.has(x)) ov++;
      if(ov>=thrA) overA.push({idx,ov});
      if(ov>=thrB) overB.push({idx,ov});
    });
    const lines=[
      `Tipp: ${v.join(" ")}`,
      `Schwellen: ‚â•${thrA} und ‚â•${thrB}`,
      `Treffer ‚â•${thrA}: ${overA.length} Varianten`,
      `Treffer ‚â•${thrB}: ${overB.length} Varianten`,
    ];
    const st=$("#tipStatus"); st.style.display=""; st.textContent = lines.join("\n");
    // Speichern als Favorit optional
  });
  $("#saveTipFav").addEventListener("click", ()=>{
    const arr = parseTipLine($("#tipInput").value);
    if(!arr.length){ alert("Bitte Zahlen eingeben."); return; }
    const note=prompt("Notiz (optional):")||"";
    const list=loadFavorites();
    list.unshift({nums:uniqSorted(arr), note, at:Date.now()});
    saveFavorites(list); renderFavorites();
    alert("Tipp gespeichert.");
  });

  /* ===================== Bereichs-Regeln (UI) ===================== */
  function updateRangeSummary(){
    const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
    const segSize=+$("#segSize").value, smin=+$("#segMin").value, smax=+$("#segMax").value;
    const map=$("#rangeMap"); map.innerHTML="";
    const summary=$("#rangeSummary");
    if(!$("#useRangeRules").checked){ summary.textContent="(aus)"; return; }
    const segs=[];
    for(let s=A; s<=B; s+=segSize){
      const e=Math.min(B, s+segSize-1);
      segs.push([s,e]);
    }
    const txt=`${segs.length} Segmente √† ${segSize} ‚Üí pro Segment ${smin}..${smax}`;
    summary.textContent=txt;
    segs.forEach(([s,e],i)=>{
      const el=document.createElement("div");
      el.className="range-seg";
      el.innerHTML = `<span class="seg-label">${s}‚Äì${e}</span><span class="seg-details">min ${smin} ¬∑ max ${smax}</span>`;
      map.appendChild(el);
    });
  }
  $("#useRangeRules").addEventListener("change", updateRangeSummary);
  ["segSize","segMin","segMax","rangeFrom","rangeTo"].forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.addEventListener("input", updateRangeSummary);
  });

  /* ===================== Ergebnisse sichern im DOM (f√ºr Export-Buttons) ===================== */
  // bereits in runGenerator/runOmega/runMother: $("#results")._variants = variants;

  /* ===================== Tests / Akzeptanzkriterien (Kurzlauf) ===================== */
  async function runEmbeddedTests(){
    const log=[];
    try{
      // 1. Sanity
      const want=50; const prev=$("#results")._variants;
      const vars = await generateSmartVariants("smart10-mix", want, null);
      log.push(`Sanity: want=${want} ‚Üí got=${vars.length}`);
      // 2. Keine langen Folgen
      let badRuns=0;
      for(const v of vars){ if(hasRunOf4(v)) badRuns++; }
      log.push(`No 4+ runs: ${badRuns===0?"OK":"BAD ("+badRuns+")"}`);
      // 3. MaxOverlap
      const maxOv=+$("#maxOv").value||5; let maxSeen=0;
      for(let i=0;i<vars.length;i++){
        const a=new Set(vars[i]);
        for(let j=i+1;j<vars.length;j++){
          let ov=0; for(const x of vars[j]) if(a.has(x)) ov++;
          if(ov>maxSeen) maxSeen=ov;
        }
      }
      log.push(`MaxOverlap seen=${maxSeen} ‚â§ ${maxOv} : ${maxSeen<=maxOv?"OK":"BAD"}`);
      // 4. Verteilung
      const A=+$("#rangeFrom").value, B=+$("#rangeTo").value;
      const cnt=new Map(); for(const v of vars) for(const z of v) cnt.set(z,(cnt.get(z)||0)+1);
      const vals=[...cnt.values()]; const mn=Math.min(...vals), mx=Math.max(...vals), avg=vals.reduce((a,b)=>a+b,0)/vals.length;
      log.push(`Distribution: min=${mn}, avg=${avg.toFixed(2)}, max=${mx}, diff=${mx-mn} (‚â§4 ideal)`);
      // 5. Simulation (kurz 2k)
      const sim = await simulateHitRates(vars, 2000);
      log.push(`Sim: P(best‚â•6)‚âà ${(100*sim.pBestGE6).toFixed(2)}%`);
      // 6. Isolation check (Omega)
      setIsolation(true, new Set(["p-archiv","p-omega"]));
      const hid = ["p-settings","p-pattern","p-hot","p-gen","p-range-rules","p-stats","p-analyse","p-favs","p-results"].every(id=> document.getElementById(id).style.display==="none");
      log.push(`Omega isolation: ${hid?"OK":"BAD"}`);
      setIsolation(false);
      // 7. Export-Struktur
      const meta={mode:"test",ts:Date.now()}, json=JSON.stringify({meta,variants:vars});
      log.push(`Export JSON length=${json.length}`);
    }catch(e){
      log.push("TEST ERROR: "+(e?.message||e));
    }
    // in Header-Kommentar w√§re zu lang ‚Äì deshalb Konsole + Status-Ausgabe
    console.log("[TEST_LOG]\\n"+log.join("\\n"));
    const rs=$("#resultStatus"); rs.style.display=""; rs.textContent = "Testlauf:\n"+log.join("\n");
  }

  // Optional automatisch kleines Testpaket nach Laden (kann kommentiert werden)
  // setTimeout(()=>{ runEmbeddedTests(); }, 800);

  /* ===================== Sicherheitshinweis ===================== */
  // Keine Garantieversprechen; nur Statistik und Simulation werden gezeigt.
  // Es werden keine Daten an Server √ºbertragen. Alles l√§uft lokal im Browser.
  