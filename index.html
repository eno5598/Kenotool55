<!doctype html>
<!--
  High-End KENO Analyse-App (2025).

  Dieses Tool:
  - beh√§lt das Archiv-System inkl. Auto-Download (archiv_keno.zip) bei,
  - beh√§lt Keno-Typ und Zahlenbereich als zentrale Einstellungen,
  - f√ºhrt einen komplexen, einstellbar intensiven Scan √ºber das ganze Archiv aus,
  - berechnet viele Muster (Frequenzen, Hot/Cold-Deviation, Streaks, Intervalle,
    Paare/Triples, Next-Draw-Pattern),
  - erzeugt 3 verschiedene 20er-Kandidatens√§tze (drei Strategien),
  - kann aus jedem Kandidatensatz Varianten erzeugen (jeweils separat),
  - kann diese Varianten mit dem gesamten Archiv vergleichen (Trefferverteilung: z.B. 8/8, 7/8, 6/8 ...).

  WICHTIG:
  - KENO-Ziehungen sind zufallsbasiert (RNG/TRNG). Es gibt KEINE Garantie, dass
    die hier vorgeschlagenen Zahlen tats√§chlich kommen.
  - Alle ‚ÄûWahrscheinlichkeiten‚Äú sind heuristische Sch√§tzungen aus Statistik & Mustern.
  - Dieses Tool soll ‚ÄûHigh-End-Analyse‚Äú liefern, aber NICHT ‚Äû80% sichere Gewinne‚Äú versprechen.
-->
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>KENO High-End Analyse-Tool</title>
  <!-- JSZip zum Entpacken von ZIP-Archiven im Browser -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    :root {
      --bg: #050816;
      --panel: #111827;
      --border: #1f2937;
      --text: #e5e7eb;
      --accent: #22c55e;
      --accent2: #0ea5e9;
      --danger: #f97373;
      --muted: #9ca3af;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000 100%);
      color: var(--text);
    }
    h1, h2, h3 {
      margin-top: 0;
      color: var(--accent);
      text-shadow: 0 0 6px rgba(34,197,94,0.4);
    }
    .container { max-width: 1200px; margin: 0 auto; }
    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 16px;
    }
    .panel {
      background: linear-gradient(145deg, rgba(15,23,42,0.95), rgba(17,24,39,0.98));
      border-radius: 12px;
      padding: 14px 16px 16px;
      border: 1px solid rgba(148,163,184,0.35);
      box-shadow: 0 18px 40px rgba(15,23,42,0.85);
      position: relative;
      overflow: hidden;
    }
    .panel::before {
      content: "";
      position: absolute;
      inset: -60%;
      background:
        radial-gradient(circle at 10% 0, rgba(56,189,248,0.12), transparent 60%),
        radial-gradient(circle at 90% 100%, rgba(74,222,128,0.12), transparent 55%);
      mix-blend-mode: screen;
      opacity: 0.7;
      pointer-events: none;
    }
    .panel > * { position: relative; }
    label { display: block; margin: 6px 0 4px; font-size: 0.9rem; }
    input[type="number"],
    input[type="text"],
    select {
      width: 100%;
      padding: 7px 9px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.9);
      color: var(--text);
      font-size: 0.9rem;
    }
    input[type="checkbox"] { margin-right: 4px; }
    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.85);
      color: var(--text);
      cursor: pointer;
      font-size: 0.88rem;
      font-weight: 500;
      transition: background 0.2s, transform 0.15s, box-shadow 0.15s, border-color 0.2s;
    }
    button.primary {
      background: linear-gradient(135deg, #22c55e, #0ea5e9);
      border: none;
      color: #02120a;
      box-shadow: 0 8px 22px rgba(45,212,191,0.4);
    }
    button.primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(45,212,191,0.55);
    }
    button.secondary:hover {
      background: rgba(30,64,175,0.55);
      transform: translateY(-1px);
    }
    button.danger {
      background: rgba(127,29,29,0.95);
      border-color: rgba(248,113,113,0.7);
      color: #fee2e2;
    }
    button.danger:hover {
      background: rgba(185,28,28,1);
      transform: translateY(-1px);
    }
    button:disabled {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    progress {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.9);
      overflow: hidden;
    }
    progress::-webkit-progress-bar { background: transparent; }
    progress::-webkit-progress-value {
      background: linear-gradient(90deg, var(--accent), var(--accent2));
    }
    progress::-moz-progress-bar {
      background: linear-gradient(90deg, var(--accent), var(--accent2));
    }
    .hint { font-size: 0.8rem; color: var(--muted); margin-top: 3px; }
    .status { font-size: 0.8rem; margin-top: 6px; }
    .status.error { color: var(--danger); }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      font-size: 0.75rem;
      color: var(--muted);
    }
    .tag {
      display: inline-block;
      padding: 2px 7px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      font-size: 0.74rem;
      margin-right: 4px;
    }
    .flex { display: flex; }
    .flex-between { display: flex; justify-content: space-between; align-items: center; }
    .flex-wrap { flex-wrap: wrap; }
    .gap-2 { gap: 8px; }
    .gap-3 { gap: 12px; }
    .mt-1 { margin-top: 4px; }
    .mt-2 { margin-top: 8px; }
    .mt-3 { margin-top: 12px; }
    .mt-4 { margin-top: 16px; }
    .section-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .top-group {
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 8px 10px;
      margin-top: 10px;
      background: radial-gradient(circle at top left, rgba(56,189,248,0.1), transparent 60%);
    }
    .top-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 6px;
    }
    .top-list {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem;
    }
    .top-number {
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      background: rgba(15,23,42,0.8);
    }
    .variants-block {
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.45);
      padding: 8px 10px;
      margin-top: 10px;
      background: radial-gradient(circle at top right, rgba(34,197,94,0.12), transparent 60%);
    }
    .variant-item {
      font-family: ui-monospace, Consolas, Menlo, monospace;
      font-size: 0.82rem;
      border-bottom: 1px dashed rgba(75,85,99,0.6);
      padding: 2px 0;
    }
    .variant-item:last-child { border-bottom: none; }
    .compare-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
      margin-top: 6px;
    }
    .compare-table th,
    .compare-table td {
      border: 1px solid rgba(55,65,81,0.9);
      padding: 2px 4px;
      text-align: center;
    }
    .compare-table th {
      background: rgba(17,24,39,0.9);
      font-weight: 500;
    }
    @media (max-width: 900px){
      .grid { grid-template-columns: minmax(0,1fr); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>KENO High-End Analyse-Tool</h1>
    <div class="hint">
      Dieses Tool analysiert dein KENO-Archiv statistisch (Hot/Cold, Deviation, Muster,
      ‚ÄûNext-Draw‚Äú-Pattern, Paare usw.) und schl√§gt 3 verschiedene Kandidatens√§tze √† 20 Zahlen vor.
      Aus jedem Satz kannst du Varianten bauen und mit dem gesamten Archiv vergleichen.
      <strong>Hinweis:</strong> KENO bleibt ein Zufallsspiel ‚Äì keine Gewinngarantie.
    </div>

    <div class="grid mt-3">
      <!-- LINKS: Archiv + Einstellungen + Scan -->
      <div class="col-left">
        <!-- 1. Archiv laden -->
        <div class="panel">
          <div class="section-title">Archiv</div>
          <h2>Archiv laden</h2>
          <label for="file">CSV/TXT/ZIP ausw√§hlen</label>
          <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
          <div id="fileStatus" class="hint mt-1">Kein Archiv geladen.</div>

          <div class="mt-2 flex gap-2 flex-wrap">
            <button id="autoLoad" class="secondary">‚¨áÔ∏è Offizielles Archiv automatisch laden</button>
            <label class="hint" style="display:inline-flex; align-items:center; gap:4px;">
              <input type="checkbox" id="autoloadOnStart">
              beim Start laden
            </label>
          </div>

          <div class="mt-2 flex gap-2 flex-wrap">
            <div style="flex:1 1 160px; min-width:0;">
              <label for="customUrl">Alternative URL (optional)</label>
              <input type="text" id="customUrl" placeholder="https://example.com/archiv_keno.zip">
            </div>
            <div style="flex:1 1 160px; min-width:0;">
              <label for="customProxy">Proxy (optional)</label>
              <input type="text" id="customProxy" placeholder="https://corsproxy.io/?">
            </div>
          </div>

          <div class="mt-2">
            <progress id="dlProg" value="0" max="1" style="display:none"></progress>
            <div id="loadStatus" class="hint"></div>
          </div>
        </div>

        <!-- 2. Einstellungen -->
        <div class="panel mt-3">
          <div class="section-title">Grund-Setup</div>
          <h2>Einstellungen</h2>

          <label for="kenoType">Keno-Typ (Anzahl Zahlen pro Tipp)</label>
          <select id="kenoType">
            <option value="2">Typ 2</option>
            <option value="3">Typ 3</option>
            <option value="4">Typ 4</option>
            <option value="5">Typ 5</option>
            <option value="6" selected>Typ 6</option>
            <option value="7">Typ 7</option>
            <option value="8">Typ 8</option>
            <option value="9">Typ 9</option>
            <option value="10">Typ 10</option>
          </select>

          <div class="flex gap-3 mt-2 flex-wrap">
            <div style="flex:1 1 120px;">
              <label for="rangeFrom">Zahlenbereich von</label>
              <input type="number" id="rangeFrom" value="1" min="1" max="200">
            </div>
            <div style="flex:1 1 120px;">
              <label for="rangeTo">Zahlenbereich bis</label>
              <input type="number" id="rangeTo" value="70" min="1" max="200">
            </div>
          </div>

          <div class="mt-2 flex gap-3 flex-wrap">
            <div style="flex:1 1 120px;">
              <label for="numVariants">Varianten pro Kandidatensatz</label>
              <input type="number" id="numVariants" value="10" min="1" max="200">
            </div>
            <div style="flex:1 1 120px;">
              <label for="overlapLimit">Max. Overlap zw. Varianten</label>
              <input type="number" id="overlapLimit" value="0" min="0" max="20">
              <div class="hint">0 = keine Begrenzung</div>
            </div>
          </div>

          <div class="mt-2 flex gap-3 flex-wrap">
            <div style="flex:1 1 120px;">
              <label for="scanRounds">Scan-Intensit√§t (Runden)</label>
              <input type="number" id="scanRounds" value="3" min="1" max="50">
              <div class="hint">Mehr Runden = l√§ngerer &amp; tiefer Analyse-Scan.</div>
            </div>
            <div style="flex:1 1 120px;">
              <label for="recentWindow">Fenster ‚Äûletzte Ziehungen‚Äú</label>
              <input type="number" id="recentWindow" value="100" min="10" max="1000">
              <div class="hint">F√ºr Hot/Cold-Auswertung.</div>
            </div>
          </div>

          <div class="mt-2 flex gap-3 flex-wrap">
            <div style="flex:1 1 120px;">
              <label for="similarityOverlap">√Ñhnlichkeits-Schwelle (Overlap)</label>
              <input type="number" id="similarityOverlap" value="8" min="1" max="20">
              <div class="hint">
                F√ºr ‚ÄûNext-Draw‚Äú-Pattern: Ziehungen mit √§hnlichem Overlap zur letzten
                Ziehung werden st√§rker gewichtet.
              </div>
            </div>
          </div>
        </div>

        <!-- 3. Analyse & Scan -->
        <div class="panel mt-3">
          <div class="section-title">Analyse</div>
          <h2>Scan &amp; Kandidaten-Berechnung</h2>

          <div class="flex gap-2 flex-wrap">
            <button id="scanBtn" class="primary">üß† Archiv scannen</button>
            <span class="pill">
              <span>Modi:</span> Hot/Cold-Deviation ¬∑ Pattern-Follow ¬∑ Cold-Rebound
            </span>
          </div>

          <progress id="scanProg" value="0" max="1" style="display:none; margin-top:10px;"></progress>
          <div id="scanStatus" class="status"></div>

          <div class="hint mt-2">
            Der Scan l√§uft in Chunks (asynchron), sodass der Browser nicht einfriert.
            Je nach Archivgr√∂√üe und Scan-Intensit√§t kann das sp√ºrbar dauern.
          </div>

          <div id="candidatesSection" style="display:none;" class="mt-3">
            <h3>3 x 20 Kandidaten-S√§tze</h3>
            <div class="hint">
              Jeder Satz basiert auf einer anderen Strategie. Du kannst einen oder mehrere
              S√§tze f√ºr die Varianten-Erzeugung ausw√§hlen.
            </div>

            <div id="candGroups"></div>
          </div>
        </div>
      </div>

      <!-- RECHTS: Varianten + Vergleich -->
      <div class="col-right">
        <!-- Varianten -->
        <div class="panel">
          <div class="section-title">Varianten</div>
          <h2>Varianten aus Kandidaten erzeugen</h2>

          <div class="flex gap-2 flex-wrap">
            <button id="genBtn" class="primary">üé≤ Varianten erzeugen</button>
            <button id="clearVarBtn" class="secondary">üßπ Varianten leeren</button>
          </div>
          <div id="varStatus" class="status"></div>

          <div id="varBlocks" class="mt-3"></div>
        </div>

        <!-- Varianten vs. Archiv -->
        <div class="panel mt-3">
          <div class="section-title">Historischer Vergleich</div>
          <h2>Varianten mit Archiv vergleichen</h2>

          <div class="flex gap-2 flex-wrap">
            <button id="compareBtn" class="primary">üìä Treffer-Verteilung berechnen</button>
          </div>
          <progress id="compareProg" value="0" max="1" style="display:none; margin-top:10px;"></progress>
          <div id="compareStatus" class="status"></div>

          <div id="compareResults" class="mt-2"></div>

          <div class="hint mt-2">
            Hier siehst du f√ºr jede Variante, wie oft sie im Archiv 0‚Ä¶S Treffer hatte
            (z.B. bei Typ 8 ‚Üí wie oft 8/8, 7/8, 6/8 usw.). Das zeigt nur, wie sich der Tipp
            HISTORISCH verhalten h√§tte ‚Äì keine Garantie f√ºr die Zukunft.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    // Kurz-Helpers
    const $  = s => document.querySelector(s);
    const el = (tag, cls) => { const x = document.createElement(tag); if(cls) x.className = cls; return x; };
    const txt = (node, s) => node && (node.textContent = s);

    const OFFICIAL_ZIP_URL =
      "https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip";

    // Globale Daten
    let g_draws = [];           // Liste von Ziehungen (Array von Zahlen)
    let g_drawSize = 0;         // typischerweise 20
    let g_scanData = null;      // alle berechneten Statistiken
    let g_candidateSets = [];   // [{id,label,type,nums:[...], meta:{...}}, ...]
    let g_variantsBySet = {};   // id -> [ {numbers:[...], hist:null|{k->count}} ]

    // ==== ARCHIV-LADEN (Upload) ====
    $('#file').addEventListener('change', async ev => {
      const file = ev.target.files[0];
      if(!file){ txt($('#fileStatus'), 'Keine Datei ausgew√§hlt.'); return; }
      try{
        if(/\.zip$/i.test(file.name)){
          await loadZipFile(file);
        } else {
          const raw = await file.text();
          parseArchive(raw);
        }
      }catch(e){
        console.error(e);
        txt($('#fileStatus'), 'Fehler beim Laden: ' + e.message);
      }
    });

    // ZIP-Datei entpacken
    async function loadZipFile(file){
      txt($('#fileStatus'), 'ZIP wird entpackt ‚Ä¶');
      const data = await file.arrayBuffer();
      const zip  = await JSZip.loadAsync(data);
      let best = null;
      zip.forEach((path, entry) => {
        const p = path.toLowerCase();
        if(entry.dir) return;
        if(p.endsWith('.csv') || p.endsWith('.txt')){
          const score =
            (p.includes('keno') ? 3 : 0) +
            (p.includes('archiv') ? 2 : 0) +
            (p.endsWith('.csv') ? 1 : 0);
          if(!best || score > best.score) best = {entry, score};
        }
      });
      if(!best){
        txt($('#fileStatus'), 'Keine CSV/TXT im ZIP gefunden.');
        return;
      }
      const raw = await best.entry.async('string');
      parseArchive(raw);
    }

    // CSV/TXT parsen ‚Üí g_draws
    function parseArchive(raw){
      const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const draws = [];
      for(const ln of lines){
        if(/zahl\s*1/i.test(ln)) continue;  // Kopfzeile(n) ignorieren
        const nums = ln.match(/\d+/g);
        if(!nums || nums.length < 10) continue;
        const arr = nums.map(x => parseInt(x,10));
        draws.push(arr);
      }
      if(draws.length === 0){
        txt($('#fileStatus'), 'Keine g√ºltigen Ziehungen gefunden.');
        return;
      }
      g_draws    = draws;
      g_drawSize = draws[0].length;
      txt($('#fileStatus'), `${draws.length} Ziehungen geladen (je ${g_drawSize} Zahlen).`);

      // Reset Analyse
      g_scanData     = null;
      g_candidateSets = [];
      g_variantsBySet = {};
      $('#scanStatus').textContent = '';
      $('#candidatesSection').style.display = 'none';
      $('#candGroups').innerHTML = '';
      $('#varStatus').textContent = '';
      $('#varBlocks').innerHTML = '';
      $('#compareStatus').textContent = '';
      $('#compareResults').innerHTML = '';
    }

    // ==== AUTO-DOWNLOAD MIT PROGRESS ====
    $('#autoLoad').addEventListener('click', () => {
      autoLoadOfficialArchive().catch(console.error);
    });

    window.addEventListener('load', () => {
      if($('#autoloadOnStart').checked){
        autoLoadOfficialArchive().catch(console.error);
      }
    });

    async function fetchWithProgress(url, onProgress){
      const res = await fetch(url);
      if(!res.ok) throw new Error('HTTP ' + res.status + ' bei ' + url);
      const total  = parseInt(res.headers.get('Content-Length')) || 0;
      const reader = res.body.getReader();
      const chunks = [];
      let received = 0;
      while(true){
        const {done, value} = await reader.read();
        if(done) break;
        chunks.push(value);
        received += value.length;
        if(onProgress) onProgress({received, total});
      }
      const blob = new Blob(chunks);
      return { arrayBuffer: await blob.arrayBuffer(), total: total || received, res };
    }

    async function attemptDownload(urls, onProgress){
      let lastError = null;
      for(const url of urls){
        try{
          const result = await fetchWithProgress(url, onProgress);
          result.usedUrl = url;
          return result;
        }catch(e){
          lastError = e;
        }
      }
      throw lastError || new Error('Download fehlgeschlagen');
    }

    async function autoLoadOfficialArchive(){
      const prog = $('#dlProg');
      const st   = $('#loadStatus');
      prog.style.display = '';
      prog.value = 0; prog.max = 1;
      txt(st, 'Verbinde zur Quelle ‚Ä¶');

      try{
        const custom = $('#customUrl').value.trim();
        const base   = custom || OFFICIAL_ZIP_URL;
        const proxy  = $('#customProxy').value.trim();
        const candidates = [];
        if(proxy) candidates.push(proxy + base);
        candidates.push(base);
        candidates.push('https://corsproxy.io/?' + encodeURIComponent(base));
        candidates.push('https://api.allorigins.win/raw?url=' + encodeURIComponent(base));
        candidates.push('https://thingproxy.freeboard.io/fetch/' + base);

        const { arrayBuffer } = await attemptDownload(candidates, ({received, total}) => {
          if(total > 0){
            prog.value = received / total;
            txt(st, `Lade Archiv ‚Ä¶ ${(100*received/total).toFixed(0)}%`);
          } else {
            prog.value = Math.min(1, prog.value + 0.02);
            txt(st, `Lade Archiv ‚Ä¶ ${received.toLocaleString()} Bytes`);
          }
        });

        txt(st, 'Entpacke ZIP ‚Ä¶');
        const zip = await JSZip.loadAsync(arrayBuffer);

        const cand = [];
        zip.forEach((path, entry) => {
          const p = path.toLowerCase();
          if(entry.dir) return;
          if(p.endsWith('.csv') || p.endsWith('.txt')){
            const score =
              (p.includes('keno') ? 3 : 0) +
              (p.includes('archiv') ? 2 : 0) +
              (p.endsWith('.csv') ? 1 : 0);
            cand.push({path, entry, score, size: entry._dataUncompressedSize || 0});
          }
        });
        if(!cand.length) throw new Error('Keine CSV/TXT im ZIP gefunden.');
        cand.sort((a,b)=> b.score - a.score || b.size - a.size);
        const best = cand[0];
        const raw  = await best.entry.async('string');
        parseArchive(raw);
        txt(st, 'Archiv geladen (Auto-Download).');
      }catch(err){
        console.error(err);
        txt(st, 'Fehler beim Download: ' + err.message);
      }finally{
        prog.style.display = 'none';
      }
    }

    // ==== SCAN & ANALYSE ====
    $('#scanBtn').addEventListener('click', () => {
      scanArchive().catch(console.error);
    });

    async function scanArchive(){
      if(!g_draws || !g_draws.length){
        txt($('#scanStatus'), 'Bitte zuerst ein Archiv laden.');
        $('#scanStatus').classList.add('error');
        return;
      }
      const A = parseInt($('#rangeFrom').value,10);
      const B = parseInt($('#rangeTo').value,10);
      if(!Number.isInteger(A) || !Number.isInteger(B) || A >= B){
        txt($('#scanStatus'), 'Ung√ºltiger Zahlenbereich.');
        $('#scanStatus').classList.add('error');
        return;
      }
      const scanRounds     = Math.max(1, parseInt($('#scanRounds').value,10) || 1);
      const recentWindow   = Math.max(10, parseInt($('#recentWindow').value,10) || 100);
      const similarityOv   = Math.max(1, parseInt($('#similarityOverlap').value,10) || 8);

      $('#scanStatus').classList.remove('error');
      txt($('#scanStatus'), 'Initialisiere Scan ‚Ä¶');
      $('#scanProg').style.display = '';
      $('#scanProg').value = 0;

      const totalDraws = g_draws.length;
      const statsNumber = {};
      for(let z = A; z <= B; z++){
        statsNumber[z] = {
          freq: 0,
          gaps: [],
          streaks: [],
          currentStreak: 0,
          lastSeen: -1,
          pairScore: 0,
          followFreq: 0,    // wie oft in ‚Äûnext draw‚Äú nach √§hnlichen Mustern
          dev: 0            // Abweichung von erwarteter H√§ufigkeit
        };
      }
      const pairCounts   = new Map();
      const overlapHist  = {};
      const lastIdx      = totalDraws - 1;
      const lastDrawSortedFull = g_draws[lastIdx].slice().sort((a,b)=>a-b);
      let prevSorted     = null;

      // Basis-Scan in Chunks
      const chunkSize = 200;
      for(let start = 0; start < totalDraws; start += chunkSize){
        const end = Math.min(totalDraws, start + chunkSize);
        for(let i = start; i < end; i++){
          const draw   = g_draws[i];
          const sorted = draw.filter(v => v>=A && v<=B).sort((a,b)=>a-b);

          // Zahlen-Stats
          for(const v of sorted){
            const st = statsNumber[v];
            st.freq++;
            if(st.lastSeen === i-1){
              st.currentStreak++;
            }else{
              if(st.currentStreak > 0) st.streaks.push(st.currentStreak);
              st.currentStreak = 1;
            }
            if(st.lastSeen >= 0){
              st.gaps.push(i - st.lastSeen);
            }
            st.lastSeen = i;
          }

          // Paare/Triples (vereinfacht, aber aussagekr√§ftig)
          const n = sorted.length;
          for(let a=0; a<n; a++){
            const vA = sorted[a];
            for(let b=a+1; b<n; b++){
              const vB = sorted[b];
              const key2 = vA + '-' + vB;
              pairCounts.set(key2, (pairCounts.get(key2)||0) + 1);
              statsNumber[vA].pairScore++;
              statsNumber[vB].pairScore++;
              // kleine Triple-Gewichtung (ohne extra Map, CPU-freundlicher)
            }
          }

          // Overlap zur vorherigen Ziehung
          if(prevSorted){
            let ov=0, p=0, q=0;
            while(p<prevSorted.length && q<sorted.length){
              if(prevSorted[p] === sorted[q]){ ov++; p++; q++; }
              else if(prevSorted[p] < sorted[q]) p++; else q++;
            }
            overlapHist[ov] = (overlapHist[ov]||0)+1;
          }
          prevSorted = sorted;
        }
        $('#scanProg').value = end / totalDraws;
        txt($('#scanStatus'), `Basisscan ‚Ä¶ ${Math.floor(100*end/totalDraws)}%`);
        await new Promise(r=>setTimeout(r,0));
      }

      // Streaks abschlie√üen
      for(let z = A; z <= B; z++){
        const st = statsNumber[z];
        if(st.currentStreak>0) st.streaks.push(st.currentStreak);
      }

      // Hot/Cold im letzten Fenster
      const freqRecent = {};
      for(let z = A; z <= B; z++) freqRecent[z]=0;
      const startRecent = Math.max(0, totalDraws - recentWindow);
      for(let i = startRecent; i < totalDraws; i++){
        for(const v of g_draws[i]){
          if(v>=A && v<=B) freqRecent[v]++;
        }
      }

      // Erwartete H√§ufigkeit (Coarse-Grained Deviation-System)
      const poolSize = (B - A + 1);
      const expected = (totalDraws * g_drawSize) / poolSize;
      for(let z = A; z <= B; z++){
        statsNumber[z].dev = statsNumber[z].freq - expected;
      }

      // Next-Draw-Pattern: wie verhalten sich ‚Äû√§hnliche‚Äú Situationen zur letzten Ziehung?
      const lastSet = new Set(lastDrawSortedFull.filter(v => v>=A && v<=B));
      const followFreq = {};
      for(let z=A; z<=B; z++) followFreq[z]=0;

      for(let i = 0; i < lastIdx; i++){
        const cur = g_draws[i].filter(v => v>=A && v<=B).sort((a,b)=>a-b);
        const next = g_draws[i+1].filter(v => v>=A && v<=B);
        // Overlap zwischen cur und letzter Ziehung
        let ov = 0;
        let p=0, q=0;
        const lastArr = Array.from(lastSet).sort((a,b)=>a-b);
        while(p<cur.length && q<lastArr.length){
          if(cur[p] === lastArr[q]){ ov++; p++; q++; }
          else if(cur[p] < lastArr[q]) p++; else q++;
        }
        if(ov >= similarityOv){
          // diese Situation ist ‚Äû√§hnlich‚Äú zur aktuellen letzten Ziehung
          for(const v of next){
            if(v>=A && v<=B) followFreq[v]++;
          }
        }
      }

      // Scan-Intensit√§t: zus√§tzliche Durchl√§ufe (z.B. verst√§rkte Muster-Smoothing)
      // Wir wiederholen einige ‚Äûsoft‚Äú-Operationen, um Rechenzeit und Gl√§ttung zu erh√∂hen.
      for(let round = 1; round < scanRounds; round++){
        txt($('#scanStatus'), `Vertiefe Muster (Runde ${round+1}/${scanRounds}) ‚Ä¶`);
        const factor = 1 + round * 0.1;
        for(let z = A; z <= B; z++){
          // leichte Verst√§rkung von Deviation & Follow-Pattern
          statsNumber[z].dev       *= factor;
          followFreq[z]            *= factor;
          statsNumber[z].pairScore *= (1 + 0.03*round);
        }
        $('#scanProg').value = 0.9 * (round/scanRounds);
        await new Promise(r=>setTimeout(r,0));
      }

      // Struktur f√ºr sp√§tere Scores
      const tempStats = {};
      const arrFreq   = [];
      const arrRecent = [];
      const arrRecency= [];
      const arrStreak = [];
      const arrPair   = [];
      const arrDev    = [];
      const arrFollow = [];

      for(let z = A; z <= B; z++){
        const st = statsNumber[z];
        const recency = (st.lastSeen >= 0) ? (totalDraws - 1 - st.lastSeen) : totalDraws;
        const avgStreak = st.streaks.length
          ? st.streaks.reduce((s,x)=>s+x,0) / st.streaks.length
          : 0;
        arrFreq.push(st.freq);
        arrRecent.push(freqRecent[z]);
        arrRecency.push(recency);
        arrStreak.push(avgStreak);
        arrPair.push(st.pairScore);
        arrDev.push(st.dev);
        arrFollow.push(followFreq[z]);

        tempStats[z] = {
          freq: st.freq,
          freqRecent: freqRecent[z],
          recency,
          avgStreak,
          pairScore: st.pairScore,
          dev: st.dev,
          followFreq: followFreq[z],
          scoreHot: 0,
          scoreCold: 0,
          scorePattern: 0
        };
      }

      function norm(arr, invert=false){
        const min = Math.min(...arr);
        const max = Math.max(...arr);
        if(max===min) return arr.map(()=>0);
        if(invert) return arr.map(v => (max - v)/(max - min));
        return arr.map(v => (v - min)/(max - min));
      }
      const NF      = norm(arrFreq);
      const NR      = norm(arrRecent);
      const NRecInv = norm(arrRecency,true); // kleinere Recency = besser
      const NS      = norm(arrStreak);
      const NP      = norm(arrPair);
      // Deviation: Hot (positiv), Cold (negativ)
      const NDevPos = norm(arrDev.map(v => Math.max(0,v)));
      const NDevNeg = norm(arrDev.map(v => Math.max(0,-v)));
      const NFollow = norm(arrFollow);

      // Gewichte f√ºr 3 Strategien:
      // 1) Hot-Bias (Hot/Cold + starke Teilnahme)
      // 2) Cold-Rebound (unterrepr√§sentierte Zahlen)
      // 3) Pattern-Follow (Follow-Freq + Streak/Overlap)

      const candHot   = [];
      const candCold  = [];
      const candPat   = [];

      let idx = 0;
      for(let z = A; z <= B; z++){
        const sHot =
          1.1*NF[idx]      +  // Gesamtfrequenz
          1.0*NR[idx]      +  // letzte Ziehungen
          0.6*NDevPos[idx] +  // positive Deviation (Hot)
          0.6*NP[idx]      +  // starke Paare
          0.4*NS[idx]      +  // Streaks
          0.3*NFollow[idx] +  // Follow-Pattern
          0.4*NRecInv[idx];   // ‚Äûfrisch aktiv‚Äú

        const sCold =
          0.5*NF[idx]       +
          0.9*NDevNeg[idx]  + // starke Unterrepr√§sentation
          0.6*NRecInv[idx]  +
          0.4*NFollow[idx]  +
          0.2*NP[idx];

        const sPat =
          1.2*NFollow[idx] +
          0.7*NP[idx]      +
          0.5*NR[idx]      +
          0.4*NS[idx]      +
          0.3*NDevPos[idx];

        tempStats[z].scoreHot     = sHot;
        tempStats[z].scoreCold    = sCold;
        tempStats[z].scorePattern = sPat;

        candHot.push({z,score:sHot});
        candCold.push({z,score:sCold});
        candPat.push({z,score:sPat});

        idx++;
      }

      candHot.sort((a,b)=>b.score-a.score);
      candCold.sort((a,b)=>b.score-a.score);
      candPat.sort((a,b)=>b.score-a.score);

      const pickTop20 = arr => arr.slice(0,20).map(x=>x.z);

      const setHot = {
        id: 'hotdev',
        label: 'System A ‚Äì Hot/Deviation',
        description: 'Betont h√§ufige & positiv abweichende Zahlen (Hot-/Deviation-Ansatz).',
        type: 'hot',
        nums: pickTop20(candHot)
      };
      const setCold = {
        id: 'coldrev',
        label: 'System B ‚Äì Cold/Rebound',
        description: 'Betont unterrepr√§sentierte ‚ÄûCold‚Äú-Zahlen mit Rebound-Idee.',
        type: 'cold',
        nums: pickTop20(candCold)
      };
      const setPat = {
        id: 'pattern',
        label: 'System C ‚Äì Pattern/Next-Draw',
        description: 'Betont Follow-Pattern nach √§hnlichen Situationen zur letzten Ziehung.',
        type: 'pattern',
        nums: pickTop20(candPat)
      };

      g_scanData      = { statsNumber, tempStats, overlapHist, freqRecent, followFreq };
      g_candidateSets = [setHot, setCold, setPat];
      g_variantsBySet = {};   // reset

      $('#scanProg').value = 1;
      $('#scanProg').style.display = 'none';
      txt($('#scanStatus'), 'Scan abgeschlossen. 3 Kandidatens√§tze berechnet.');

      renderCandidateSets();
    }

    function renderCandidateSets(){
      const sec  = $('#candidatesSection');
      const wrap = $('#candGroups');
      wrap.innerHTML = '';
      if(!g_candidateSets.length){
        sec.style.display = 'none';
        return;
      }
      sec.style.display = '';

      for(const set of g_candidateSets){
        const box = el('div','top-group');

        const header = el('div','top-header');
        const left   = el('div');
        const title  = el('div');
        title.innerHTML = `<strong>${set.label}</strong>`;
        const desc   = el('div','hint');
        desc.textContent = set.description;
        left.appendChild(title);
        left.appendChild(desc);

        const right  = el('label','hint');
        right.style.display = 'inline-flex';
        right.style.alignItems = 'center';
        right.style.gap = '4px';
        const cb = el('input');
        cb.type  = 'checkbox';
        cb.checked = true;
        cb.dataset.setId = set.id;
        right.appendChild(cb);
        right.appendChild(document.createTextNode('f√ºr Varianten nutzen'));
        header.appendChild(left);
        header.appendChild(right);

        const list = el('div','top-list');
        set.nums.forEach((z,idx)=>{
          const chip = el('span','top-number');
          chip.textContent = z;
          list.appendChild(chip);
        });

        box.appendChild(header);
        box.appendChild(list);
        wrap.appendChild(box);
      }
    }

    function getSelectedCandidateSets(){
      const selected = [];
      const checkboxes = document.querySelectorAll('input[type="checkbox"][data-set-id]');
      const byId = new Map(g_candidateSets.map(s => [s.id,s]));
      checkboxes.forEach(cb=>{
        if(cb.checked){
          const set = byId.get(cb.dataset.setId);
          if(set) selected.push(set);
        }
      });
      return selected;
    }

    // ==== VARIANTEN ERZEUGEN ====
    $('#genBtn').addEventListener('click', () => {
      try { generateVariants(); } catch(e){ console.error(e); }
    });

    $('#clearVarBtn').addEventListener('click', () => {
      g_variantsBySet = {};
      $('#varBlocks').innerHTML = '';
      txt($('#varStatus'), 'Varianten gel√∂scht.');
      $('#compareResults').innerHTML = '';
      $('#compareStatus').textContent = '';
    });

    function generateVariants(){
      if(!g_candidateSets.length){
        txt($('#varStatus'), 'Bitte zuerst scannen, um Kandidaten zu erhalten.');
        return;
      }
      const selectedSets = getSelectedCandidateSets();
      if(!selectedSets.length){
        txt($('#varStatus'), 'Bitte mindestens einen Kandidatensatz ausw√§hlen.');
        return;
      }

      const S     = parseInt($('#kenoType').value,10);
      const want  = Math.max(1, parseInt($('#numVariants').value,10) || 1);
      const ovLim = Math.max(0, parseInt($('#overlapLimit').value,10) || 0);

      if(!S || S < 1){
        txt($('#varStatus'), 'Ung√ºltiger Keno-Typ.');
        return;
      }

      g_variantsBySet = {};   // neu erzeugen
      const blocksWrap = $('#varBlocks');
      blocksWrap.innerHTML = '';

      // Hilfsfunktionen
      const hasLongRun = (arr) => {
        let run = 1;
        for(let i=1; i<arr.length; i++){
          if(arr[i] === arr[i-1] + 1){
            run++;
            if(run >= 4) return true;    // 4+ aufeinanderfolgende vermeiden
          }else{
            run = 1;
          }
        }
        return false;
      };
      const computeOverlap = (a,b) => {
        let ov=0, i=0, j=0;
        while(i<a.length && j<b.length){
          if(a[i] === b[j]){ ov++; i++; j++; }
          else if(a[i] < b[j]) i++; else j++;
        }
        return ov;
      };

      for(const set of selectedSets){
        const pool = set.nums.slice();
        const results = [];
        const seen   = new Set();

        let attempts = 0;
        const maxAttempts = want * 300;

        while(results.length < want && attempts < maxAttempts){
          attempts++;
          // Mischung aus ‚ÄûWheel‚Äú und Zufall: wir permutieren, nehmen S aus 20
          const shuffled = pool.slice().sort(()=>Math.random()-0.5);
          const variant  = shuffled.slice(0,S).sort((a,b)=>a-b);

          if(hasLongRun(variant)) continue;
          const key = variant.join(',');
          if(seen.has(key)) continue;

          if(ovLim > 0){
            let ok = true;
            for(const v of results){
              if(computeOverlap(v.numbers, variant) > ovLim){ ok=false; break; }
            }
            if(!ok) continue;
          }

          results.push({numbers:variant, hist:null});
          seen.add(key);
        }

        g_variantsBySet[set.id] = results;

        // UI-Block
        const block = el('div','variants-block');
        const head  = el('div','flex-between');
        const tag   = el('div');
        tag.innerHTML = `<strong>${set.label}</strong>`;
        const meta  = el('div','hint');
        meta.textContent = `${results.length} Varianten generiert (Basis: 20 Zahlen).`;
        head.appendChild(tag);
        head.appendChild(meta);

        const list = el('div','mt-2');
        results.forEach((v,idx)=>{
          const row = el('div','variant-item');
          row.textContent = `#${String(idx+1).padStart(2,'0')}  ` + v.numbers.join(' ');
          list.appendChild(row);
        });

        block.appendChild(head);
        block.appendChild(list);
        blocksWrap.appendChild(block);
      }

      const totalVar = Object.values(g_variantsBySet).reduce((s,arr)=>s+arr.length,0);
      txt($('#varStatus'), `${totalVar} Varianten √ºber ${selectedSets.length} Kandidatens√§tze erzeugt.`);
      $('#compareResults').innerHTML = '';
      $('#compareStatus').textContent = '';
    }

    // ==== VARIANTEN vs ARCHIV VERGLEICH ====
    $('#compareBtn').addEventListener('click', () => {
      compareVariantsWithArchive().catch(console.error);
    });

    async function compareVariantsWithArchive(){
      if(!g_draws || !g_draws.length){
        txt($('#compareStatus'),'Bitte zuerst ein Archiv laden.');
        return;
      }
      const S = parseInt($('#kenoType').value,10);
      if(!S || S < 1){
        txt($('#compareStatus'),'Ung√ºltiger Keno-Typ.');
        return;
      }

      const sets = Object.keys(g_variantsBySet);
      if(!sets.length){
        txt($('#compareStatus'),'Bitte zuerst Varianten erzeugen.');
        return;
      }
      const totalVariants = Object.values(g_variantsBySet).reduce((s,arr)=>s+arr.length,0);
      if(!totalVariants){
        txt($('#compareStatus'),'Keine Varianten zum Vergleichen vorhanden.');
        return;
      }

      $('#compareProg').style.display = '';
      $('#compareProg').value = 0;
      txt($('#compareStatus'),'Vergleiche Varianten mit Archiv ‚Ä¶');

      const totalDraws = g_draws.length;
      let processed = 0;

      // Pre-Sort draws f√ºr schnelleren Overlap
      const sortedDraws = g_draws.map(dr => dr.slice().sort((a,b)=>a-b));

      // F√ºr jede Variante: Histogramm der Treffer 0..S
      for(const setId of sets){
        const arr = g_variantsBySet[setId];
        for(const v of arr){
          const hist = {};
          for(let k=0; k<=S; k++) hist[k]=0;

          const variant = v.numbers;
          const lenV    = variant.length;

          for(let i=0; i<totalDraws; i++){
            const d = sortedDraws[i];
            let ov=0, p=0,q=0;
            while(p<lenV && q<d.length){
              if(variant[p] === d[q]){ ov++; p++; q++; }
              else if(variant[p]<d[q]) p++; else q++;
            }
            if(ov> S) ov=S;
            hist[ov] = (hist[ov]||0)+1;
          }
          v.hist = hist;
          processed++;
          if(processed % 5 === 0){
            $('#compareProg').value = processed / totalVariants;
            await new Promise(r=>setTimeout(r,0));
          }
        }
      }

      $('#compareProg').value = 1;
      $('#compareProg').style.display = 'none';
      txt($('#compareStatus'),'Vergleich abgeschlossen.');
      renderCompareResults(S);
    }

    function renderCompareResults(S){
      const wrap = $('#compareResults');
      wrap.innerHTML = '';

      const sets = g_candidateSets.filter(s => g_variantsBySet[s.id] && g_variantsBySet[s.id].length);

      for(const set of sets){
        const arr = g_variantsBySet[set.id];
        if(!arr.length) continue;
        const box = el('div','variants-block');
        const head = el('div','flex-between');
        const t1   = el('div');
        t1.innerHTML = `<strong>${set.label}</strong>`;
        const t2   = el('div','hint');
        t2.textContent = `${arr.length} Varianten ¬∑ Treffer 0‚Ä¶${S} √ºber ${g_draws.length} Ziehungen`;
        head.appendChild(t1); head.appendChild(t2);
        box.appendChild(head);

        const table = el('table','compare-table');
        const thead = el('thead');
        const trh   = el('tr');
        trh.appendChild(th('Var.'));
        for(let k=S; k>=0; k--){
          trh.appendChild(th(`${k}/${S}`));
        }
        thead.appendChild(trh);
        table.appendChild(thead);

        const tbody = el('tbody');
        arr.forEach((v,idx)=>{
          const tr = el('tr');
          tr.appendChild(td('#'+String(idx+1).padStart(2,'0')));
          for(let k=S; k>=0; k--){
            const val = (v.hist && v.hist[k]) || 0;
            tr.appendChild(td(val.toString()));
          }
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        box.appendChild(table);
        wrap.appendChild(box);
      }

      function th(text){ const x = document.createElement('th'); x.textContent = text; return x; }
      function td(text){ const x = document.createElement('td'); x.textContent = text; return x; }
    }

    // Hinweis: Ein ausf√ºhrlicherer Self-Test k√∂nnte hier erg√§nzt werden.
    // Wegen Performance im echten Archiv ist er standardm√§√üig deaktiviert.

  })();
  </script>
</body>
</html>