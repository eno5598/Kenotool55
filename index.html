<!doctype html>
<!--
  Neue KENO Analyse‑App (2025).

  Diese Anwendung vereint die wichtigsten Teile des alten KENO‑Tools (Archiv‑Upload
  inklusive Auto‑Download, Keno‑Typ‑Einstellung, Zahlenbereich) mit einer
  komplett neu entwickelten Analyse‑Engine. Nach dem Laden eines Archivs kann
  der Nutzer einen Scan starten, der das gesamte Archiv asynchron durchläuft,
  umfangreiche Statistiken berechnet und daraus eine Top‑20‑Liste an
  Kandidatenzahlen erstellt. Anschließend können aus diesen 20 Zahlen Varianten
  generiert werden – entsprechend dem gewählten Keno‑Typ und optionalen
  Einstellungen. Alle Berechnungen sind rein heuristisch: es gibt keine
  Gewinngarantie.
-->
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>KENO Analyse‑App</title>
  <!-- JSZip wird benötigt, um ZIP‑Archive im Browser zu entpacken -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    :root {
      --bg: #0a1128;
      --panel: #14213d;
      --border: #1f2a54;
      --text: #e1e9ff;
      --accent: #00f5a0;
      --accent2: #00bbf9;
      --danger: #f43f5e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 16px;
      font-family: ui-monospace, Consolas, Menlo, monospace;
      background: linear-gradient(135deg, var(--bg), #100c2d 50%, var(--bg));
      color: var(--text);
    }
    h1, h2, h3 {
      margin-top: 0;
      color: var(--accent);
      text-shadow: 0 0 4px var(--accent2), 0 0 8px var(--accent);
    }
    .container { max-width: 1100px; margin: 0 auto; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    label { display: block; margin: 6px 0 4px; }
    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
    }
    input[type="checkbox"] { margin-right: 4px; }
    button {
      display: inline-block;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      font-weight: bold;
      transition: background 0.3s, transform 0.2s;
    }
    button.primary {
      background: linear-gradient(135deg, #059669, #22c55e);
      color: #04110a;
      border: none;
    }
    button.primary:hover { background: linear-gradient(135deg, #06b981, #34d58c); transform: translateY(-1px); }
    button.secondary { background: var(--panel); border: 1px solid var(--border); }
    button.secondary:hover { background: #1e2c5c; }
    button.danger { background: #7f1d1d; border: 1px solid #991b1b; color: #fee2e2; }
    button.danger:hover { background: #991b1b; transform: translateY(-1px); }
    progress {
      width: 100%; height: 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg);
      overflow: hidden;
    }
    progress::-webkit-progress-bar { background: var(--bg); }
    progress::-webkit-progress-value { background: var(--accent); }
    .top-item, .variant-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 6px;
      border-bottom: 1px solid var(--border);
      font-family: ui-monospace, Consolas, Menlo, monospace;
    }
    .hint { font-size: 0.85em; color: #9ca3af; margin-top: 4px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>KENO Analyse‑App</h1>
    <!-- 1. Archiv‑Panel -->
    <div class="panel">
      <h2>Archiv laden</h2>
      <label for="file">CSV/TXT/ZIP auswählen</label>
      <input type="file" id="file" accept=".csv,.txt,.zip,text/csv,application/zip,application/octet-stream,text/plain">
      <div id="fileStatus" class="hint">Kein Archiv geladen.</div>
      <div style="margin-top: 10px;">
        <button id="autoLoad" class="secondary">⬇️ Offizielles Archiv automatisch laden</button>
        <label style="display:inline-flex; align-items:center; gap:4px; margin-left:12px;"><input type="checkbox" id="autoloadOnStart"> beim Start laden</label>
      </div>
      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap: wrap;">
        <div style="flex:1 1 200px;">
          <label for="customUrl">Alternative URL (optional)</label>
          <input type="text" id="customUrl" placeholder="https://example.com/archive.zip">
        </div>
        <div style="flex:1 1 200px;">
          <label for="customProxy">Proxy (optional)</label>
          <input type="text" id="customProxy" placeholder="https://corsproxy.io/?">
        </div>
      </div>
      <div style="margin-top:10px;">
        <progress id="dlProg" value="0" max="1" style="display:none"></progress>
        <div id="loadStatus" class="hint"></div>
      </div>
    </div>
    <!-- 2. Einstellungen -->
    <div class="panel">
      <h2>Einstellungen</h2>
      <label for="kenoType">Keno‑Typ (Anzahl Zahlen pro Tipp)</label>
      <select id="kenoType">
        <option value="2">Typ 2</option>
        <option value="3">Typ 3</option>
        <option value="4">Typ 4</option>
        <option value="5">Typ 5</option>
        <option value="6" selected>Typ 6</option>
        <option value="7">Typ 7</option>
        <option value="8">Typ 8</option>
        <option value="9">Typ 9</option>
        <option value="10">Typ 10</option>
      </select>
      <label for="rangeFrom">Zahlenbereich: von</label>
      <input type="number" id="rangeFrom" value="1" min="1" max="200">
      <label for="rangeTo">Zahlenbereich: bis</label>
      <input type="number" id="rangeTo" value="70" min="1" max="200">
      <label for="numVariants">Variantenanzahl</label>
      <input type="number" id="numVariants" value="10" min="1" max="100">
      <label for="overlapLimit">Max. Overlap zwischen Varianten (optional)</label>
      <input type="number" id="overlapLimit" value="0" min="0" max="20">
    </div>
    <!-- 3. Analyse‑Panel -->
    <div class="panel">
      <h2>Analyse &amp; Scan</h2>
      <button id="scanBtn" class="primary">Scannen</button>
      <progress id="scanProg" value="0" max="1" style="display:none; margin-top:10px;"></progress>
      <div id="scanStatus" class="hint"></div>
      <div id="topSection" style="display:none; margin-top: 16px;">
        <h3>Top‑20 Kandidaten</h3>
        <div class="hint">Basierend auf Musteranalyse – keine Gewinngarantie!</div>
        <div id="topList" style="margin-top:8px;"></div>
      </div>
    </div>
    <!-- 4. Varianten‑Panel -->
    <div class="panel" id="varPanel" style="display:none;">
      <h2>Varianten generieren</h2>
      <button id="genBtn" class="primary">Varianten erzeugen</button>
      <div id="varStatus" class="hint"></div>
      <div id="variantsList" style="margin-top: 12px;"></div>
    </div>
  </div>
  <script>
  (function(){
    'use strict';
    // Kurzschreibweisen
    const $ = sel => document.querySelector(sel);
    const text = (el, t) => { if(el) el.textContent = t; };
    // Konstanten
    const OFFICIAL_ZIP_URL = "https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip";
    // Globale Daten
    let g_draws = [];
    let g_drawSize = 0;
    let g_scores = null;
    let g_topNumbers = null;
    let g_stats = null;
    // ==== ARCHIV-LADEN ====
    // Datei-Upload
    $('#file').addEventListener('change', async ev => {
      const file = ev.target.files[0];
      if(!file){ text($('#fileStatus'), 'Keine Datei ausgewählt.'); return; }
      try{
        if(/\.zip$/i.test(file.name)){
          await loadZipFile(file);
        } else {
          const raw = await file.text();
          parseArchive(raw);
        }
      }catch(e){ console.error(e); text($('#fileStatus'), 'Fehler beim Laden: '+e.message); }
    });
    // Auto-Download starten
    $('#autoLoad').addEventListener('click', async ()=>{
      try{ await autoLoadOfficialArchive(); }catch(err){ console.error(err); }
    });
    // Beim Start autoload
    window.addEventListener('load', () => {
      if($('#autoloadOnStart').checked){ autoLoadOfficialArchive().catch(console.error); }
    });
    // JSZip-Datei entpacken und parsen
    async function loadZipFile(file){
      text($('#fileStatus'), 'ZIP wird entpackt …');
      const data = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(data);
      // Suche nach CSV/TXT
      let best = null;
      zip.forEach((path, entry) => {
        const p = path.toLowerCase();
        if(entry.dir) return;
        if(/\.csv$/.test(p) || /\.txt$/.test(p)){
          const score = (/keno/.test(p)?3:0) + (/archiv/.test(p)?2:0) + (p.endsWith('.csv')?1:0);
          if(!best || score > best.score){ best = {entry, score}; }
        }
      });
      if(!best){ text($('#fileStatus'), 'Keine gültige CSV/TXT im ZIP.'); return; }
      const raw = await best.entry.async('string');
      parseArchive(raw);
    }
    // Text-Datei parsen → g_draws
    function parseArchive(raw){
      const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const draws = [];
      for(const ln of lines){
        // Headerzeilen mit „Zahl“ ignorieren
        if(/zahl\s*1/i.test(ln)) continue;
        const nums = ln.match(/\d+/g);
        if(!nums || nums.length < 5) continue;
        const arr = nums.map(x => parseInt(x,10));
        draws.push(arr);
      }
      if(draws.length === 0){ text($('#fileStatus'), 'Keine gültigen Ziehungen gefunden.'); return; }
      g_draws = draws;
      g_drawSize = draws[0].length;
      text($('#fileStatus'), `${draws.length} Ziehungen geladen (Größe ${g_drawSize}).`);
      // Reset Analyse
      g_scores = null; g_topNumbers = null; g_stats = null;
      $('#scanStatus').textContent = '';
      $('#topSection').style.display = 'none';
      $('#varPanel').style.display = 'none';
    }
    // ==== AUTO‑DOWNLOAD (übernommen aus altem Tool) ====
    async function fetchWithProgress(url, onProgress){
      const res = await fetch(url);
      if(!res.ok) throw new Error('HTTP '+res.status+' bei '+url);
      const total = parseInt(res.headers.get('Content-Length')) || 0;
      const reader = res.body.getReader();
      let received = 0;
      const chunks = [];
      while(true){
        const {done, value} = await reader.read();
        if(done) break;
        chunks.push(value);
        received += value.length;
        if(typeof onProgress === 'function') onProgress({ received, total });
      }
      const blob = new Blob(chunks);
      return { arrayBuffer: await blob.arrayBuffer(), total: total||received, res };
    }
    async function attemptDownload(urls, onProgress){
      let lastError = null;
      for(const url of urls){
        try{
          const result = await fetchWithProgress(url, onProgress);
          result.usedUrl = url;
          return result;
        }catch(e){ lastError = e; }
      }
      throw lastError || new Error('Download fehlgeschlagen');
    }
    async function autoLoadOfficialArchive(){
      const prog = $('#dlProg');
      const st = $('#loadStatus');
      // UI vorbereiten
      prog.style.display = '';
      prog.value = 0; prog.max = 1;
      text(st, 'Verbinde zur Quelle …');
      try{
        // Basis-URL und Proxy
        const custom = $('#customUrl').value.trim();
        const baseUrl = custom || OFFICIAL_ZIP_URL;
        const proxy = $('#customProxy').value.trim();
        // Kandidatenliste erstellen: Proxy hat Priorität
        const candidates = [];
        if(proxy){ candidates.push(proxy + baseUrl); }
        candidates.push(baseUrl);
        candidates.push('https://corsproxy.io/?' + encodeURIComponent(baseUrl));
        candidates.push('https://api.allorigins.win/raw?url=' + encodeURIComponent(baseUrl));
        candidates.push('https://thingproxy.freeboard.io/fetch/' + baseUrl);
        // Download starten
        const { arrayBuffer, usedUrl } = await attemptDownload(candidates, ({received, total}) => {
          if(total > 0){ prog.value = received/total; text(st, `Lade Archiv … ${(100*received/total).toFixed(0)}%`); }
          else { prog.value = Math.min(1, prog.value + 0.02); text(st, `Lade Archiv … ${received.toLocaleString()} Bytes`); }
        });
        text(st, 'Entpacke ZIP …');
        const zip = await JSZip.loadAsync(arrayBuffer);
        // Finde eine CSV/TXT im ZIP
        const candidates2 = [];
        zip.forEach((path, entry) => {
          const p = path.toLowerCase();
          if(entry.dir) return;
          if(p.endsWith('.csv') || p.endsWith('.txt')){
            const score = (/keno/.test(p)?3:0) + (/archiv/.test(p)?2:0) + (p.endsWith('.csv')?1:0);
            candidates2.push({ path, entry, score, size: entry._dataUncompressedSize||0 });
          }
        });
        if(!candidates2.length) throw new Error('Keine CSV/TXT im ZIP gefunden');
        candidates2.sort((a,b) => b.score - a.score || b.size - a.size);
        const best = candidates2[0];
        const raw = await best.entry.async('string');
        parseArchive(raw);
        text(st, 'Archiv geladen (via Auto‑Download).');
        // Hinweis an fileStatus
        text($('#fileStatus'), `${g_draws.length} Ziehungen geladen (Größe ${g_drawSize}).`);
      }catch(err){
        console.error(err);
        text(st, 'Fehler beim Download: '+err.message);
      }finally{
        prog.style.display = 'none';
      }
    }
    // ==== SCAN & ANALYSE ====
    $('#scanBtn').addEventListener('click', async ()=>{
      try{ await scanArchive(); }catch(err){ console.error(err); }
    });
    async function scanArchive(){
      if(!g_draws || g_draws.length === 0){ text($('#scanStatus'), 'Bitte zuerst ein Archiv laden.'); return; }
      const A = parseInt($('#rangeFrom').value, 10);
      const B = parseInt($('#rangeTo').value, 10);
      if(!Number.isInteger(A) || !Number.isInteger(B) || A > B){ text($('#scanStatus'), 'Ungültiger Zahlenbereich.'); return; }
      const total = g_draws.length;
      // Initialisieren
      const statsNumber = {};
      for(let z = A; z <= B; z++){
        statsNumber[z] = {
          freq: 0,
          lastSeen: -1,
          currentStreak: 0,
          streaks: [],
          gaps: [],
          pairScore: 0,
        };
      }
      const pairCounts = new Map();
      const tripleCounts = new Map();
      const overlapHist = {};
      let prevSorted = null;
      $('#scanProg').style.display = '';
      $('#scanProg').value = 0;
      text($('#scanStatus'), 'Starte Scan …');
      // Async Schleife in Chunks
      const chunkSize = 200;
      for(let start = 0; start < total; start += chunkSize){
        const end = Math.min(total, start + chunkSize);
        for(let i = start; i < end; i++){
          const draw = g_draws[i];
          const sorted = draw.filter(x => x >= A && x <= B).sort((a,b) => a-b);
          // Stats für jede Zahl
          for(const v of sorted){
            const st = statsNumber[v];
            st.freq += 1;
            if(st.lastSeen === i-1){ st.currentStreak += 1; }
            else {
              if(st.currentStreak > 0) st.streaks.push(st.currentStreak);
              st.currentStreak = 1;
            }
            if(st.lastSeen >= 0){ st.gaps.push(i - st.lastSeen); }
            st.lastSeen = i;
          }
          // Paar/Triple
          const n = sorted.length;
          for(let a = 0; a < n; a++){
            const vA = sorted[a];
            for(let b = a+1; b < n; b++){
              const vB = sorted[b];
              const key2 = vA + '-' + vB;
              pairCounts.set(key2, (pairCounts.get(key2) || 0) + 1);
              statsNumber[vA].pairScore += 1;
              statsNumber[vB].pairScore += 1;
              for(let c = b+1; c < n; c++){
                const vC = sorted[c];
                const key3 = key2 + '-' + vC;
                tripleCounts.set(key3, (tripleCounts.get(key3) || 0) + 1);
                statsNumber[vA].pairScore += 1;
                statsNumber[vB].pairScore += 1;
                statsNumber[vC].pairScore += 1;
              }
            }
          }
          // Overlap
          if(prevSorted){
            let ov = 0; let p = 0, q = 0;
            while(p < prevSorted.length && q < sorted.length){
              if(prevSorted[p] === sorted[q]){ ov++; p++; q++; }
              else if(prevSorted[p] < sorted[q]) p++; else q++;
            }
            overlapHist[ov] = (overlapHist[ov] || 0) + 1;
          }
          prevSorted = sorted;
        }
        // Fortschritt nach jedem Chunk
        $('#scanProg').value = end / total;
        text($('#scanStatus'), `Scanne Archiv … ${Math.floor((end/total)*100)}%`);
        await new Promise(r => setTimeout(r, 0));
      }
      // Finale Streaks schließen
      for(let z = A; z <= B; z++){
        const st = statsNumber[z];
        if(st.currentStreak > 0) st.streaks.push(st.currentStreak);
      }
      // Häufigkeiten der letzten N Ziehungen (z.B. 50)
      const recentWindow = 50;
      const startRecent = Math.max(0, total - recentWindow);
      const freqRecent = {};
      for(let z = A; z <= B; z++) freqRecent[z] = 0;
      for(let i = startRecent; i < total; i++){
        const draw = g_draws[i];
        for(const v of draw){ if(v >= A && v <= B) freqRecent[v] += 1; }
      }
      // Score berechnen
      const values = { freq: [], recent: [], recency: [], streak: [], pair: [], gapBonus: [] };
      const tempStats = {};
      for(let z = A; z <= B; z++){
        const st = statsNumber[z];
        const recency = (st.lastSeen >= 0) ? (total - 1 - st.lastSeen) : total;
        const avgStreak = st.streaks.length ? st.streaks.reduce((s,x) => s+x,0) / st.streaks.length : 0;
        let gapBonus = 0;
        if(st.gaps.length >= 2){
          const gc = {};
          let maxCount = 0, topGap = 0;
          for(const g of st.gaps){ gc[g] = (gc[g] || 0) + 1; if(gc[g] > maxCount){ maxCount = gc[g]; topGap = g; } }
          const lastGap = st.gaps[st.gaps.length - 1];
          const diff = Math.abs(lastGap - topGap);
          const dominance = maxCount / st.gaps.length;
          const closeness = 1 - Math.min(diff / (topGap*2 || 1), 1);
          gapBonus = dominance * closeness;
        }
        values.freq.push(st.freq);
        values.recent.push(freqRecent[z]);
        values.recency.push(recency);
        values.streak.push(avgStreak);
        values.pair.push(st.pairScore);
        values.gapBonus.push(gapBonus);
        tempStats[z] = { freq: st.freq, freqRecent: freqRecent[z], recency, avgStreak, pairScore: st.pairScore, gapBonus };
      }
      // Normalisierungsfunktion
      function norm(arr, invert=false){
        const min = Math.min(...arr), max = Math.max(...arr);
        if(max === min) return arr.map(() => 0);
        return arr.map(v => invert ? (max - v)/(max - min) : (v - min)/(max - min));
      }
      const nf = norm(values.freq);
      const nr = norm(values.recent);
      const nrec = norm(values.recency);
      const ns = norm(values.streak);
      const np = norm(values.pair);
      const ng = norm(values.gapBonus);
      const weights = { freq: 1.0, recent: 1.0, recency: 0.5, streak: 0.5, pair: 0.5, gap: 0.7 };
      g_scores = {};
      g_topNumbers = [];
      let idx = 0;
      for(let z = A; z <= B; z++){
        const score = weights.freq * nf[idx] + weights.recent * nr[idx] + weights.recency * (1 - nrec[idx]) + weights.streak * ns[idx] + weights.pair * np[idx] + weights.gap * ng[idx];
        g_scores[z] = score;
        tempStats[z].score = score;
        idx++;
      }
      // Sortiere Top 20
      const allNums = Object.keys(g_scores).map(n => parseInt(n,10));
      allNums.sort((a,b) => g_scores[b] - g_scores[a]);
      g_topNumbers = allNums.slice(0, 20);
      // Stats speichern
      g_stats = tempStats;
      // UI
      $('#scanProg').value = 1;
      $('#scanProg').style.display = 'none';
      text($('#scanStatus'), 'Scan abgeschlossen.');
      renderTopList();
      $('#varPanel').style.display = '';
    }
    function renderTopList(){
      if(!g_topNumbers){ return; }
      $('#topSection').style.display = '';
      const list = $('#topList');
      list.innerHTML = '';
      g_topNumbers.forEach((z,i) => {
        const st = g_stats[z];
        const div = document.createElement('div');
        div.className = 'top-item';
        div.innerHTML = '<span><strong>#' + String(i+1).padStart(2,'0') + '</strong> ' + z + '</span>' +
                        '<span>Score: ' + st.score.toFixed(3) + ' · Häufig: ' + st.freq + ' · Letzte: ' + st.recency + '</span>';
        list.appendChild(div);
      });
    }
    // ==== VARIANTEN ====
    $('#genBtn').addEventListener('click', () => {
      try{ generateVariants(); }catch(err){ console.error(err); }
    });
    function generateVariants(){
      if(!g_topNumbers || g_topNumbers.length === 0){
        text($('#varStatus'), 'Bitte zuerst scannen.');
        return;
      }
      // Anzahl Zahlen pro Tipp (Keno‑Typ)
      const S = parseInt($('#kenoType').value, 10);
      // Anzahl gewünschter Varianten
      const want = parseInt($('#numVariants').value, 10) || 0;
      // Maximale erlaubte Überschneidung zwischen zwei Varianten (0 bedeutet: keine Prüfung)
      const overlapLim = parseInt($('#overlapLimit').value, 10);
      if(!S || S < 1){
        text($('#varStatus'), 'Ungültiger Keno‑Typ.');
        return;
      }
      // Pool der Kandidaten (die Top‑20 Liste). Kopie erstellen, damit wir sie verändern können.
      const pool = g_topNumbers.slice();
      const results = [];
      const seenKeys = new Set();
      // Hilfsfunktion, um zu prüfen, ob eine Variante eine zu lange Folge (>=3) hat
      function hasLongRun(arr){
        let run = 1;
        for(let i=1; i<arr.length; i++){
          if(arr[i] === arr[i-1] + 1){
            run++;
            if(run >= 3) return true;
          } else {
            run = 1;
          }
        }
        return false;
      }
      // Hilfsfunktion, um den Overlap zweier sortierter Varianten zu berechnen
      function computeOverlap(a,b){
        let ov = 0;
        let i = 0, j = 0;
        while(i < a.length && j < b.length){
          if(a[i] === b[j]){ ov++; i++; j++; }
          else if(a[i] < b[j]) i++; else j++;
        }
        return ov;
      }
      // Wir versuchen, zufällig Variationen zu generieren, bis wir genug haben oder zu viele Versuche hatten.
      let attempts = 0;
      const maxAttempts = want * 200;
      while(results.length < want && attempts < maxAttempts){
        attempts++;
        // Erzeuge eine Variante, indem du S unterschiedliche Zahlen aus dem Pool zufällig auswählst.
        const shuffled = pool.slice().sort(() => Math.random() - 0.5);
        const variant = shuffled.slice(0, S).sort((a,b) => a - b);
        // Prüfe auf zu lange aufeinanderfolgende Runs (optional)
        if(hasLongRun(variant)) continue;
        // Schlüsseldarstellung prüfen, um Duplikate zu verhindern
        const key = variant.join(',');
        if(seenKeys.has(key)) continue;
        // Overlap‑Limit prüfen (wenn >0)
        if(overlapLim > 0){
          let ok = true;
          for(const v of results){
            if(computeOverlap(v, variant) > overlapLim){ ok = false; break; }
          }
          if(!ok) continue;
        }
        results.push(variant);
        seenKeys.add(key);
      }
      // Ausgabe der Varianten
      const list = $('#variantsList');
      list.innerHTML = '';
      if(results.length === 0){
        text($('#varStatus'), 'Keine gültigen Varianten gefunden.');
        return;
      }
      results.forEach((arr, idx) => {
        const div = document.createElement('div');
        div.className = 'variant-item';
        div.textContent = '#' + String(idx+1).padStart(2,'0') + '  ' + arr.join(' ');
        list.appendChild(div);
      });
      text($('#varStatus'), results.length + ' Varianten generiert.');
    }
    // ==== SELF‑TESTS ====
    // Einfache Selbsttests im Hintergrund, um die grundlegenden Funktionen zu überprüfen.
    function runSelfTests(){
      console.log('Starte Selbsttests …');
      // Test‑Archiv: 5 Ziehungen mit 10 Zahlen
      const testDraws = [
        [1,2,3,4,5,6,7,8,9,10],
        [2,4,6,8,10,12,14,16,18,20],
        [1,3,5,7,9,11,13,15,17,19],
        [10,20,30,40,50,60,70,80,90,100],
        [5,10,15,20,25,30,35,40,45,50]
      ];
      g_draws = testDraws;
      g_drawSize = 10;
      // Test: Stats & Scan
      $('#rangeFrom').value = '1';
      $('#rangeTo').value = '100';
      scanArchive().then(() => {
        console.log('Selbsttest: Scan abgeschlossen, Top20:', g_topNumbers);
        // Test: Varianten
        $('#kenoType').value = '5';
        $('#numVariants').value = '5';
        generateVariants();
        console.log('Selbsttest: Varianten generiert:', g_topNumbers);
      });
    }
    // Führe die Tests nach kurzer Verzögerung aus, aber nur im Entwicklungskontext
    // Hinweis: im Produktivbetrieb auskommentieren oder entfernen
    // setTimeout(runSelfTests, 0);
  })();
  </script>
</body>
</html>