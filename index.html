<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>KENO ‚Äì Mini Generator (Archiv + sinnvolle Verteilung)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b1220;--panel:#131c31;--muted:#1b2743;--text:#e7eefc;
    --accent:#77f2c8;--accent2:#5db2ff;--danger:#ff5470;--ok:#8bff9c;
  }
  *{box-sizing:border-box}
  body{margin:0;padding:18px;font:15px/1.5 Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(135deg,#0b1220 0%,#080c16 100%);color:var(--text)}
  h1,h2{margin:0 0 8px}
  .box{max-width:1100px;margin:0 auto}
  .panel{background:linear-gradient(180deg,var(--panel),#0f1730);border:1px solid #213054;border-radius:14px;padding:14px;margin-top:14px;box-shadow:0 6px 18px rgba(0,0,0,.35)}
  label{display:block;margin-bottom:6px;font-weight:600}
  input[type="number"],input[type="text"],select{width:100%;padding:10px;border-radius:10px;border:1px solid var(--muted);background:#0a1327;color:var(--text)}
  input[type="file"]{width:100%}
  button{padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:800}
  .primary{background:linear-gradient(135deg,#37e6ad,#51f1ff);color:#031a14}
  .secondary{background:#14213d;color:var(--text);border:1px solid var(--muted)}
  .ghost{background:transparent;border:1px dashed var(--muted);color:var(--text)}
  .danger{background:#6b1220;color:#ffe6ea;border:1px solid #8a1a2c}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>div{flex:1 1 220px}
  .status{margin-top:6px;padding:10px;border-radius:10px;border:1px solid var(--muted);background:#0a1327;white-space:pre-wrap}
  .results .item{display:flex;gap:8px;align-items:center;background:#0a1327;border:1px solid var(--muted);padding:8px;border-radius:10px;margin:6px 0}
  .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--muted);border-radius:999px;padding:4px 10px;background:#0a1327}
  .mono{font-family:ui-monospace,Consolas,Menlo,monospace}
  progress{width:100%;height:12px}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(230px,1fr));gap:8px}
  .hint{color:#b7c2dd;font-size:13px}
</style>
</head>
<body>
<div class="box">
  <h1>üóÇÔ∏è KENO ‚Äì Mini Generator</h1>
  <div class="panel">
    <p class="hint">Liest das offizielle Archiv (CSV/TXT oder ZIP), erzeugt <b>sinnvoll verteilte</b> Varianten mit robustem Zufall und optionaler Ber√ºcksichtigung der letzten 10‚Äì50 Ziehungen.</p>
  </div>

  <!-- Archiv -->
  <div class="panel">
    <h2>Archiv</h2>
    <div class="row">
      <div>
        <label>Datei w√§hlen (CSV/TXT oder ZIP)</label>
        <input type="file" id="file" accept=".csv,.txt,.zip,text/plain,text/csv,application/zip">
        <div class="hint">Offizielles ZIP (manuell laden): <a href="https://www.lotto-bayern.de/static/gamebroker_2/de/download_files/archiv_keno.zip" target="_blank" rel="noopener">archiv_keno.zip</a></div>
      </div>
      <div>
        <label>Archiv-Status</label>
        <div id="archStatus" class="status">Kein Archiv geladen.</div>
        <div class="row" style="margin-top:6px">
          <button id="clearArch" class="danger">Archiv l√∂schen</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Einstellungen -->
  <div class="panel">
    <h2>Einstellungen</h2>
    <div class="row">
      <div>
        <label>KENO-Typ</label>
        <select id="kenoType">
          <option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option selected>10</option>
        </select>
      </div>
      <div>
        <label>Varianten (z.‚ÄØB. 30)</label>
        <input type="number" id="variants" min="1" max="500" value="30">
      </div>
      <div>
        <label>Max. √úberschneidung zwischen Varianten</label>
        <input type="number" id="maxOverlap" min="0" max="10" value="5">
      </div>
      <div>
        <label>Seed (leer = sicherer Zufall)</label>
        <input type="text" id="seed" placeholder="optional">
      </div>
    </div>
    <div class="row" style="margin-top:6px">
      <div>
        <label>Letzte Ziehungen ber√ºcksichtigen</label>
        <select id="window">
          <option value="off" selected>Aus</option>
          <option value="10">Letzte 10</option>
          <option value="25">Letzte 25</option>
          <option value="50">Letzte 50</option>
          <option value="all">Gesamtes Archiv</option>
        </select>
        <div class="hint">Wenn an: ‚Äûhei√üe‚Äú Zahlen werden leicht bevorzugt, ‚Äûkalte‚Äú leicht bestraft.</div>
      </div>
      <div>
        <label>Bereich</label>
        <div class="row">
          <div><input type="number" id="from" value="1" min="1" max="200"></div>
          <div><input type="number" id="to" value="70" min="1" max="200"></div>
        </div>
        <div class="hint">Standard: 1‚Äì70</div>
      </div>
    </div>
  </div>

  <!-- Generieren -->
  <div class="panel">
    <h2>Generieren</h2>
    <div class="row">
      <button id="go" class="primary">Varianten erzeugen</button>
      <button id="dlCsv" class="secondary">Als CSV speichern</button>
      <button id="copy" class="ghost">üìã In Zwischenablage</button>
    </div>
    <div id="genInfo" class="status">Bereit.</div>
  </div>

  <!-- Ergebnisse -->
  <div class="panel">
    <h2>Ergebnisse</h2>
    <div id="results" class="results"></div>
  </div>

  <!-- Analyse -->
  <div class="panel">
    <h2>Analyse</h2>
    <div id="report" class="status">Noch nichts erzeugt.</div>
  </div>
</div>

<!-- JSZip (f√ºr ZIP-Archive) -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
(function(){
  "use strict";
  const $=s=>document.querySelector(s);
  const text=(el,s)=>{if(el) el.textContent=s};
  const uniq=(a)=>Array.from(new Set(a));
  const sortNums=(a)=>a.slice().sort((x,y)=>x-y);
  const sum=a=>a.reduce((s,x)=>s+x,0);

  const CACHE="keno_mini_archive_v1";
  let gDraws=[], gLen=0;

  /* ------------------ Robust RNG ------------------ */
  function xoshiro128ss(seed){
    // seed: 64-bit via splitmix, accepts string/number
    function splitmix64(x){
      x = BigInt.asUintN(64, BigInt(x));
      let z = (x + 0x9E3779B97F4A7C15n) & 0xFFFFFFFFFFFFFFFFn;
      z = (z ^ (z >> 30n)) * 0xBF58476D1CE4E5B9n & 0xFFFFFFFFFFFFFFFFn;
      z = (z ^ (z >> 27n)) * 0x94D049BB133111EBn & 0xFFFFFFFFFFFFFFFFn;
      return z ^ (z >> 31n);
    }
    function rotl(x,k){ return (x<<k | x>>(32-k))>>>0; }
    // map seed to 4x32
    const h = Number(splitmix64(seed) & 0xffffffffn)>>>0;
    const h2= Number((splitmix64(seed+1n)>>32n) & 0xffffffffn)>>>0;
    const h3= Number(splitmix64(seed+2n) & 0xffffffffn)>>>0;
    const h4= Number((splitmix64(seed+3n)>>32n) & 0xffffffffn)>>>0;
    let a=h,b=h2,c=h3,d=h4;
    return function(){
      const t = (b<<9)>>>0;
      let r = (a * 5)>>>0; r = rotl(r,7); r = (r * 9)>>>0;
      let q = b ^ a; q>>>0;
      a = b ^ c ^ d; a>>>0;
      b = (b ^ q ^ (q<<14))>>>0;
      c = (c ^ b)>>>0;
      d = (d ^ c)>>>0;
      c = (c ^ t)>>>0;
      d = rotl(d,11);
      return (r>>>0)/4294967296;
    };
  }
  function makeRngFromSeedInput(seedStr){
    if(!seedStr){
      // Crypto-Seed
      const u = new Uint32Array(2);
      crypto.getRandomValues(u);
      return xoshiro128ss(BigInt((BigInt(u[0])<<32n) | BigInt(u[1])));
    }
    // Hash simple: FNV-1a 64
    let h = 0xcbf29ce484222325n;
    for(const ch of String(seedStr)){
      h ^= BigInt(ch.codePointAt(0));
      h = BigInt.asUintN(64, h * 0x100000001b3n);
    }
    return xoshiro128ss(h);
  }

  /* ------------------ Archiv laden ------------------ */
  function splitSmart(line){
    if(/\t/.test(line)) return line.split("\\t");
    if(line.includes(";")) return line.split(";");
    if(line.includes("|")) return line.split("|");
    if(/,/.test(line) && !/^\\d+(?:-\\d+)+$/.test(line.trim())) return line.split(",");
    return line.trim().split(/\\s+/);
  }
  function parseTable(text){ return text.split(/\\r?\\n/).map(r=>r.trim()).filter(Boolean).map(splitSmart); }
  function detectDashCol(rows){
    let maxCols=0; for(const r of rows) maxCols=Math.max(maxCols,r.length);
    let best=-1,score=-1;
    for(let c=0;c<maxCols;c++){
      let sc=0;
      for(const r of rows){
        const cell=(r[c]||"").trim();
        if(!cell) continue;
        const parts=cell.split("-");
        if(parts.length>=5 && parts.every(p=>/^\\d+$/.test(p))) sc++;
      }
      if(sc>score){score=sc;best=c;}
    }
    return best;
  }
  function tryZahlHeader(rows){
    if(!rows.length) return null;
    const header=rows[0], idx=[];
    for(let i=0;i<header.length;i++) if(/^zahl\\s*\\d+$/i.test(String(header[i]).trim())) idx.push(i);
    if(idx.length>=5){
      const lists=[]; for(let r=1;r<rows.length;r++){
        const nums=idx.map(i=>parseInt(String(rows[r][i]||"").trim(),10)).filter(Number.isInteger);
        if(nums.length) lists.push(nums);
      }
      return {lists, info:"Header erkannt"};
    }
    return null;
  }
  function fallbackExtract(raw){
    const out=[];
    for(const lnRaw of raw.split(/\\r?\\n/)){
      const ln=lnRaw.trim(); if(!ln) continue;
      if(/^\\d+(?:-\\d+)+$/.test(ln)){ out.push(ln.split("-").map(n=>parseInt(n,10))); continue; }
      const nums=(ln.match(/\\d+/g)||[]).map(x=>parseInt(x,10)).filter(Number.isInteger);
      if(nums.length>=5) out.push(nums);
    }
    return out;
  }
  function loadArchiveFromRawText(raw, label){
    const rows=parseTable(raw);
    let lists=[], detected="";
    const z=tryZahlHeader(rows);
    if(z){ lists=z.lists; detected=z.info; }
    else{
      const dc=detectDashCol(rows);
      if(dc>=0){
        for(const r of rows){
          const cell=String(r[dc]||"").trim(); if(!cell) continue;
          const parts=cell.split("-");
          if(parts.length && parts.every(p=>/^\\d+$/.test(p))) lists.push(parts.map(x=>parseInt(x,10)));
        }
        detected="Spalte 1-4-‚Ä¶";
      }else{
        lists=fallbackExtract(raw);
        detected="Fallback: freie Zahlzeilen";
      }
    }
    if(!lists.length) throw new Error("Keine g√ºltigen Zahlen erkannt.");
    // dominante L√§nge
    const cnt=new Map();
    for(const a of lists) cnt.set(a.length,(cnt.get(a.length)||0)+1);
    let bestL=0,bestC=-1;
    for(const [k,v] of cnt.entries()){ if(v>bestC){bestC=v;bestL=k;} }
    const filtered = lists.filter(a=>a.length===bestL).map(a=>sortNums(uniq(a)));
    if(!filtered.length) throw new Error("Nach Filter leer.");
    gDraws = filtered;
    gLen   = bestL;
    try{ localStorage.setItem(CACHE, JSON.stringify({gDraws,gLen,label,savedAt:Date.now()})); }catch{}
    text($("#archStatus"), `Archiv geladen: ${gDraws.length} Ziehungen ¬∑ L√§nge ${gLen} (${detected})${label? " ¬∑ Quelle: "+label:""}`);
  }
  async function handleAnyFile(file){
    if(!file) return;
    text($("#archStatus"), "Lese Datei ‚Ä¶");
    const name=file.name.toLowerCase();
    try{
      if(name.endsWith(".zip")){
        if(!window.JSZip) throw new Error("JSZip fehlt");
        const ab=await file.arrayBuffer();
        const zip=await JSZip.loadAsync(ab);
        const cands=[];
        zip.forEach((p,e)=>{
          const pl=p.toLowerCase();
          if(pl.endsWith(".csv")||pl.endsWith(".txt")){
            const score=(/keno/i.test(pl)?2:0)+(/archiv/i.test(pl)?1:0);
            cands.push({p,e,score,size:e._dataUncompressedSize||0});
          }
        });
        cands.sort((a,b)=> b.score-b.score || b.size-a.size);
        if(!cands.length) throw new Error("Keine CSV/TXT im ZIP");
        const raw = await cands[0].e.async("string");
        loadArchiveFromRawText(raw, "ZIP:"+cands[0].p);
      }else{
        const txt = await file.text();
        loadArchiveFromRawText(txt, file.name||"Upload");
      }
    }catch(e){
      text($("#archStatus"), "Fehler: "+(e?.message||e));
    }
  }
  $("#file").addEventListener("change", ()=> handleAnyFile($("#file").files[0]));
  $("#clearArch").addEventListener("click", ()=>{ localStorage.removeItem(CACHE); gDraws=[]; gLen=0; text($("#archStatus"), "Archiv gel√∂scht."); });

  // Init from cache
  (function(){
    try{
      const raw=localStorage.getItem(CACHE);
      if(raw){
        const o=JSON.parse(raw); if(o && o.gDraws && o.gDraws.length){ gDraws=o.gDraws; gLen=o.gLen; text($("#archStatus"), `Archiv aus Cache: ${gDraws.length} Ziehungen ¬∑ L√§nge ${gLen}`); }
      }
    }catch{}
  })();

  /* ------------------ Statistik-Helfer ------------------ */
  function computeStats(A,B,windowMode){
    const total=gDraws.length;
    let start=0;
    if(windowMode==="10") start=Math.max(0,total-10);
    else if(windowMode==="25") start=Math.max(0,total-25);
    else if(windowMode==="50") start=Math.max(0,total-50);
    else if(windowMode==="all") start=0;
    else if(windowMode==="off") start=0; // aber sp√§ter Gewicht=0
    const draws = (windowMode==="off") ? gDraws : gDraws.slice(start);
    const n=B-A+1;
    const freq=Array(n).fill(0);
    for(const d of draws){
      for(const v of d){
        if(v>=A && v<=B) freq[v-A]++;
      }
    }
    return {freq,windowCount:draws.length};
  }

  /* ------------------ Sinnvolle Verteilung ------------------
     - Greedy + Strafpunkte:
       ‚Ä¢ Segment-Balance (Dekaden 1‚Äì10, 11‚Äì20, ‚Ä¶)
       ‚Ä¢ Adjazenz-Strafe (¬±1) + Viererfolge verboten
       ‚Ä¢ Paar-Strafe (Vermeide in derselben Variante extrem h√§ufige Paare)
       ‚Ä¢ Globale Abdeckung (Zahlen gleichm√§√üig √ºber alle Varianten verteilen)
       ‚Ä¢ Hei√ü/Kalt-Weights aus Statistikfenster
     -------------------------------------------------------- */
  function makeVariants(){
    const k = parseInt($("#kenoType").value,10);
    const want = +$("#variants").value;
    const maxOv = +$("#maxOverlap").value;
    const A = +$("#from").value, B=+$("#to").value;
    if(!(k>=2 && k<=10)) return text($("#genInfo"), "Ung√ºltiger KENO-Typ.");
    if(B<A) return text($("#genInfo"), "Bereich falsch.");
    if(!gDraws.length) return text($("#genInfo"), "Bitte zuerst Archiv laden.");

    const rng = makeRngFromSeedInput($("#seed").value.trim());
    const {freq,windowCount}=computeStats(A,B,$("#window").value);
    const N=B-A+1;
    const baseP = Array(N).fill(1);
    // Hei√ü/Kalt ‚Äì nur wenn Fenster != off
    if($("#window").value!=="off"){
      const maxF = Math.max(1, ...freq);
      for(let i=0;i<N;i++){
        const hot = freq[i]/(maxF||1);
        baseP[i] = 0.8 + 0.9*hot; // 0.8‚Äì1.7
      }
    }

    const segSize=10; // Dekaden
    const segIdx = i => Math.floor((i)/segSize); // i = 0..N-1
    const SEG_COUNT = Math.ceil(N/segSize);
    const segMin=0, segMax=Math.max(2, Math.ceil(k/2)); // weiches Limit

    // globale Abdeckung: z√§hlt, wie oft eine Zahl bereits in allen Varianten vorkam
    const globalUse = Array(N).fill(0);

    // Hilfsfunktionen
    const pickWeighted = (weights, forbidSet)=>{
      let s=0;
      for(let i=0;i<N;i++) if(!forbidSet.has(i)) s+=Math.max(0,weights[i]);
      if(s<=0){ // Fallback uniform
        const avail=[...Array(N).keys()].filter(i=>!forbidSet.has(i));
        const r = avail[Math.floor(rng()*avail.length)];
        return r;
      }
      let r = rng()*s;
      for(let i=0;i<N;i++){
        if(forbidSet.has(i)) continue;
        r-=Math.max(0,weights[i]);
        if(r<=0) return i;
      }
      return N-1;
    };

    const variants=[];

    function scoreCandidate(curIdxs, candidate){
      // candidate ist Index 0..N-1 (real = A+idx)
      const sIdx = segIdx(candidate);
      const segCounts = new Array(SEG_COUNT).fill(0);
      for(const c of curIdxs) segCounts[segIdx(c)]++;
      const adjPenalty = curIdxs.some(x => Math.abs(x - candidate)===1) ? 0.85 : 1;
      // 4er-Folge verhindern
      const withCand = sortNums(curIdxs.concat([candidate]));
      let consec=1, bad=false;
      for(let i=1;i<withCand.length;i++){
        if(withCand[i]===withCand[i-1]+1){ consec++; if(consec>=4){ bad=true; break; } }
        else consec=1;
      }
      if(bad) return -1;
      // Segment-Penalty (weich)
      const segP = (segCounts[sIdx] >= segMax) ? 0.7 : 1;
      const coverageP = 1.2 / (1 + globalUse[candidate]); // bevorzugt selten genutzte Zahlen global
      return segP * adjPenalty * coverageP;
    }

    const seenCombos = new Set();
    function tooSimilar(arr){
      if(variants.length===0) return false;
      // Max-Overlap pr√ºfen
      for(const v of variants){
        let same=0;
        let i=0,j=0;
        while(i<v.length && j<arr.length){
          if(v[i]===arr[j]){ same++; i++; j++; }
          else if(v[i]<arr[j]) i++; else j++;
        }
        if(same>maxOv) return true;
      }
      return false;
    }

    for(let t=0; t<want; t++){
      const forbid = new Set();
      const chosen=[];
      const weights = baseP.slice();
      let safety=0;
      while(chosen.length<k && safety<5000){
        safety++;
        // Score-justierung je Kandidat
        const scored = [];
        for(let i=0;i<N;i++){
          if(forbid.has(i)) continue;
          const s = scoreCandidate(chosen, i);
          if(s<=0) continue;
          scored.push([i, weights[i]*s]);
        }
        if(!scored.length){
          // Fallback: lockere Forbids und versuche neu
          if(chosen.length===0){ break; }
          forbid.clear();
          continue;
        }
        // Normiere auf Auswahl
        let total=0; for(const [,w] of scored) total+=w;
        let r=rng()*total;
        let pick=scored[0][0];
        for(const [idx,w] of scored){ r-=w; if(r<=0){ pick=idx; break; } }
        chosen.push(pick);
        forbid.add(pick);
        // leichte Sperre benachbarter Zahlen, um Klumpen zu vermeiden
        if(pick-1>=0) forbid.add(pick-1);
        if(pick+1<N) forbid.add(pick+1);
      }
      if(chosen.length!==k){ t--; continue; } // nochmal versuchen
      const combo = sortNums(chosen.map(i=>A+i));
      if(tooSimilar(combo)){ t--; continue; }
      const key = combo.join(",");
      if(seenCombos.has(key)){ t--; continue; }
      seenCombos.add(key);
      // globale Abdeckung aktualisieren
      for(const i of chosen) globalUse[i]++;
      variants.push(combo);
    }

    // Ausgabe
    const res=$("#results");
    res.innerHTML="";
    variants.forEach((v,idx)=>{
      const div=document.createElement("div"); div.className="item";
      div.innerHTML = `<span class="badge">#${idx+1}</span> <span class="mono">${v.join(" ")}</span>`;
      res.appendChild(div);
    });

    // Analyse erstellen
    const usage = new Map();
    for(const v of variants) for(const n of v) usage.set(n,(usage.get(n)||0)+1);
    const usageArr = Array.from(usage.entries()).sort((a,b)=> b[1]-a[1]);
    const avg = (sum(variants.map(v=>v.length))/variants.length)||0;
    // Overlap-Histogramm
    const hist = new Map();
    for(let i=0;i<variants.length;i++){
      for(let j=i+1;j<variants.length;j++){
        // Schnittgr√∂√üe
        let a=variants[i], b=variants[j], p=0, q=0, same=0;
        while(p<a.length && q<b.length){
          if(a[p]===b[q]){ same++; p++; q++; }
          else if(a[p]<b[q]) p++; else q++;
        }
        hist.set(same,(hist.get(same)||0)+1);
      }
    }
    const histTxt = Array.from(hist.entries()).sort((a,b)=>a[0]-b[0]).map(([k,v])=>`${k}: ${v}`).join(", ");
    const topUsed = usageArr.slice(0,10).map(([n,c])=>`${n}√ó${c}`).join("  ");
    const info =
`Erzeugt: ${variants.length} Varianten ¬∑ KENO-Typ ${k}
Fenster: ${$("#window").value} ¬∑ Bereich: ${A}-${B}
√ò Zahlen/Variante: ${avg.toFixed(2)}
Top genutzte Zahlen: ${topUsed || "‚Äì"}
Overlap-Histogramm (Schnittgr√∂√üen): ${histTxt || "‚Äì"}`;
    text($("#genInfo"), "Fertig.");
    text($("#report"), info);

    // CSV/Copy Hilfen
    window.__kenoVariants = variants;
  }

  $("#go").addEventListener("click", makeVariants);

  $("#dlCsv").addEventListener("click", ()=>{
    const v = (window.__kenoVariants||[]);
    if(!v.length) return alert("Noch keine Varianten.");
    const csv = v.map(a=>a.join(";")).join("\\n");
    const blob = new Blob([csv], {type:"text/csv"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download="keno_varianten.csv";
    a.click();
  });
  $("#copy").addEventListener("click", ()=>{
    const v = (window.__kenoVariants||[]);
    if(!v.length) return alert("Noch keine Varianten.");
    const txt = v.map(a=>a.join(" ")).join("\\n");
    navigator.clipboard.writeText(txt).then(()=>{
      text($("#genInfo"), "In die Zwischenablage kopiert.");
    });
  });
})();</script>
</body>
</html>
